<!DOCTYPE html>
<html lang="fi" >
<head>
  <script src="jquery.min.js"></script>
    <link href="jquerysctipttop.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="bootstrap.min.css">
    <link rel="stylesheet" href="styles.css"> 
    <script src="d3.v5.min.js"></script>
  <script src="d3.layout.cloud.js"></script>

<style>
.hero-image {
  background-image: url("tvtaustakuva.svg");
  background-color: #ffffff;
  height: 800px;
  width: 800px;
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
  position: relative;
  opacity: 50%;
}
.tcontainer { 
	max-width: 960px; 
	height: 100%;
	margin: 0 auto; 
	padding: 20px;
}

.tabs {
	position: relative;
	display: flex;
	min-height: 800px;
	border-radius: 8px 8px 0 0;
	overflow: hidden;
}

.tabby-tab {
	flex: 1;
}

.tabby-tab label {
	display: block;
	box-sizing: border-box;
	/* tab content must clear this */
		height: 40px;
	
	padding: 10px;
	text-align: center;
	background: #97ded1;
	cursor: pointer;
	transition: background 0.5s ease;
	
}

.tabby-tab label:hover {
	background: #7bacab;
}

.tabby-content {
	position: absolute;
	
	left: 0; bottom: 0; right: 0;
	/* clear the tab labels */
		top: 40px; 
	
	padding: 0px;
	border-radius: 0 0 8px 8px;

	
	transition: 
		opacity 0.8s ease,
		transform 0.8s ease		;
	
	/* show/hide */
		opacity: 0;
		transform: scale(0.1);
		transform-origin: top left;
	
}

.tabby-content img {
	float: left;
	margin-right: 20px;
	border-radius: 8px;
}


/* MAKE IT WORK ----- */

.tabby-tab [type=radio] { display: none; }
[type=radio]:checked ~ label {
	background: #7bacab;
	z-index: 2;
}

[type=radio]:checked ~ label ~ .tabby-content {
	z-index: 1;
	
	/* show/hide */
		opacity: 1;
		transform: scale(1);
}

/* BREAKPOINTS ----- */
@media screen and (max-width: 767px) {
	.tabs { min-height: 400px;}
}

@media screen and (max-width: 480px) {
	.tabs { min-height: 580px; }
	.tabby-tab label { 
		height: 60px;
	}
	.tabby-content { top: 60px; }
	.tabby-content img {
		float: none;
		margin-right: 0;
		margin-bottom: 20px;
	}
}
.slip-reordering {
    box-shadow: 0 2px 10px rgba(0,0,0,0.45);
}

.slip-swiping-container {
    overflow-x: hidden;
}

.slippylist li {
    user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    cursor: default;
}

/* the rest is junk for the demo page */
.slippylist li.demo-allow-select {
    padding: 1em;
    line-height: 1.3;
    user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
}
.slippylist li.demo-allow-select span {
    cursor: text;
}

.slippylist {
    max-width: 15em;
    clear:left;
    margin: 1em;
    padding: 0 0 1px;
}

.slippylist li {
    display: block;
    position: relative;
    border: 1px solid black;
    background: white;
    margin: 0; padding: 0 1em;
    border-radius: 3px;
    margin-bottom: -1px;
    max-width: 100%;
    line-height: 1.5;
    vertical-align: middle;
}

.slippylist input {
    vertical-align: middle;
}

.slippylist .instant::before {
    /*content: " ↑ ↓ ";*/
    content: "[";
    color: white;
}
.slippylist .instant {
    float: left;
}
.slippylist li::after {
    content: "[";
    color: white;
}

.skewed {
    transform: rotate(2deg) scale(0.99);
    -webkit-transform: rotate(2deg) scale(0.99);
}

.demo-no-swipe.demo-no-reorder {
    opacity: 0.5;

}

#scroll {
    overflow-y: scroll;
    max-height: 300px;
}

h1, h2, h3 {
    color: #666;
}
h1 {
    float:left;
    margin-top: 0;
    margin-right: 1ex;
}
h3 {
    margin-bottom: 0.2em;
    margin-top: 2em;
}
h1+p {
    overflow:auto;
    margin-top: 0.2em;
}

.button {
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
}

.container {
  position: relative;
  top: 50%;
  left: 50%;
  width: 320px;
  height: 400px;
  opacity: 0;
  visibility: hidden;
  transform: translate(-50%, -50%); 
}

.list-item {
  position: absolute;
  top: 0;
  left: 0;
  height: 30px;
  width: 100%;
}

.item-content {
  height: 100%;
  border: 0px solid rgba(123, 123, 123, 0.498039);
  border-radius: 4px;
  color: #999999;
  line-height: 30px;
  padding-left: 32px;
  font-size: 24px;
  font-weight: 400;
  background-color: white;
  box-shadow: rgba(0, 0, 0, 0.2) 0px 1px 2px 0px;
}



h2.box-headline.letters.rotate-2 {
opacity : 0.6;
text-align: center;
}

.box-headline {
  font-size: 30px;
  line-height: 0.6;
  font-family: 'Sofia Pro', sans-serif;
  color: #7bacab;
}



html,
body {
/*background-color: #FC5A5D;*/
  width: 100vw;
  height: 100vh;
  margin: 0;
  border: 0;
  padding: 0;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

*,
*::before,
*::after {
  -webkit-box-sizing: inherit;
  -moz-box-sizing: inherit;
  box-sizing: inherit;
  box-sizing: border-box; 
}

.slider {
  padding: 3rem 0;
}
.slider > ul.slider-items {
  --_spacer: 1rem;
  display: grid;
  gap: var(--_spacer);
  grid-auto-flow: column;
  grid-auto-columns: 80vw;
  padding: 0 var(--_spacer) var(--_spacer);
  overflow-x: auto;
  overscroll-behavior-inline: contain;
  -ms-scroll-snap-type: inline mandatory;
      scroll-snap-type: inline mandatory;
  scroll-padding-inline: var(--_spacer, 1rem);

}
.slider > ul.slider-items::-webkit-scrollbar {
  height: 8px;
  border-radius: 8px;
}
.slider > ul.slider-items::-webkit-scrollbar-track {
  background: rgba(29, 55, 104, 0.15);
  border-radius: 8px;
}
.slider > ul.slider-items::-webkit-scrollbar-thumb {
  background: rgba(29, 55, 104, 0.75);
  border-radius: 8px;
}
.slider > ul.slider-items::-webkit-scrollbar-thumb:hover {
  background: #1d3768;
}
.slider > ul.slider-items > li {
  display: flex;
  scroll-snap-align: center;
  background: #e4e4e4;
  flex-direction: column;
  gap: 5px;
  padding: 1.5rem;
  font-family: Arial, sans-serif;
  color: #1D3768;
}
.slider > ul.slider-items > li > * {
  margin: 0;
}
.slider > ul.slider-items > li h3 {
  font-size: 24px;
  font-weight: bold;
}
.slider > ul.slider-dots {
  margin: 0;
  margin-top: 2rem;
  padding: 0;
  list-style: none;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}
.slider > ul.slider-dots > li {
  width: 8px;
  height: 8px;
  background: #1D3768;
  border-radius: 100%;
  opacity: 0.5;
  transition: opacity 0.2s ease-in-out;
}
.slider > ul.slider-dots > li.active {
  opacity: 1;
}


.point {
  mix-blend-mode: multiply;
}

.frame {
  fill: none;
  stroke: #000;
}

.axis text {
  font: 10px sans-serif;
}

.axis line {
  fill: none;
  stroke: #ebebeb;
}

.axis circle {
  fill: none;
  stroke: #aaa;
}

.axis:last-of-type circle {
  stroke: #333;
}

.line {
  fill: none;
  stroke: orange;
  stroke-width: 3px;
}
        .brushed {
            fill: #ffea55;
            stroke: #e1ea10;
            opacity: 1.0;
        }

        .non_brushed {
            fill: #e8c840;
            opacity: 0.5;
        }


.selection {
  /* add a solid border to the brush */
  stroke: rgba(0, 0, 0, 0.3);
}

#main {
  display: flex;
}

.label {
  fill: black;
  font-size: 12px;
}


	
</style>

</head>
<body>
<div class="slider">
	<ul class="slider-items">
		<li data-id="0">
<table>	
<td>		

</td>
<td>
TYÖVALMENNUKSEN PALVELUTARPEEN ITSEARVIOINTI
<br><br>
<b>Itsearvioinnin avulla voit määrittää mitkä työllistymisen kannalta keskeiset asiat ovat mielestäsi kunnossa ja missä asioissa kaipaisit eniten apua.</b>
<br><br>
Näin käytät itsearviointia
<br><br>
1. Valitse sinulle merkitykselliset sanat neljästä sanapilvestä, klikkaamalla  kerran jos sana kuvaa jo hyvin halussa olevaa asiaa, tai klikkaamalla sanaa kaksi kertaa jos sana kuvaa mielestäsi kehittämistarvetta. Jo hoidossa olevat asiat merkitään vihreällä, kehitystarpeet punaisella. 
<br><br>
2. Käy kaikki neljä aluetta läpi 
<br>
a) Resurssit kuvaavat saatavilla olevia työnhaun materiaaleja, palveluja ja verkostoja.
<br>
b) Valmiudet kuvaavat työelämävaatimuksia
<br>
c) Työnhaku kuvaa käytettävissäsi olevia keinoja löytää työpaikka 
<br>
d) Työpaikka kuvaa etenemistä rekrytointiprosessista eteenpäin
<br><br>
3. Voit katsoa kuinka mielestäsi tärkeät asiat sijoittuvat kehälle, klikkaamalla sanapilvien alapuolella olevaa välilehteä <b>Työvalmemmus</b>
<br><br>
<STRIKE>4. Saat lisätietoja maalaamalla joitakin valitsemistasi sanoista. Voit maalaamisen jälkeen myös siirellä aluetta.</STRIKE>
<br><br>

<STRIKE>5. Valittujen sanojen yläkäsitteiden avulla voit tarkastella esimerkiksi sosiaalisia sidoksia kohdasta <b> Itsetuntemus </b>ja <b>Osallisuusvalmennus</b></STRIKE>
</td>
</table>
		</li>		
		<li data-id="1">	
        <h2 class="box-headline letters rotate-2"><b>Resurssit</b></h2>
        <svg id="wordcloud1"></svg>   
        <h2 class="box-headline letters rotate-2"><b>Materiaalit - Palvelut - Verkostot</b></h2>
		</li>
		<li data-id="2">
        <h2 class="box-headline letters rotate-2"><b>Valmiudet</b>	</h2>
        <svg id="wordcloud2"></svg>
        <h2 class="box-headline letters rotate-2"><b>Asenteet - Kyvyt - Taidot</b></h2> 
		</li>
		<li data-id="3">
        <h2 class="box-headline letters rotate-2"><b>Työnhaku</b></h2>
        <svg id="wordcloud3"></svg>
        <h2 class="box-headline letters rotate-2"><b>Valmennukset - Strategiat - Suunnitelmat</b></h2>  
		</li>
		<li data-id="4">
        <h2 class="box-headline letters rotate-2"><b>Työpaikka</b></h2>
        <svg id="wordcloud4"></svg>
        <h2 class="box-headline letters rotate-2"><b>Rekrytointi - Sopimukset - Työympäristö</b></h2>  
		</li>
	</ul>
	<ul class="slider-dots">
		<li class="active"></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>	
	</ul>
</div>


<div class="tcontainer">
	

	<div class="tabs">
		<div onClick="vihreat()" class="tabby-tab">
			<input type="radio" id="tab-1" name="tabby-tabs">
			<label for="tab-1">Järjestely</label>
			<div class="tabby-content">
<table>
<td>Resurssit
<ol id="demo1" class="slippylist"></ol>
</td>
<td>	Valmiudet
<ol id="demo2" class="slippylist"></ol>
</td>
<td>Työnhaku
<ol id="demo3" class="slippylist"></ol>
</td>
<td>	Työpaikka
<ol id="demo4" class="slippylist"></ol>
</td>
</table>
			</div>
		</div>

		<div class="tabby-tab">
			<input type="radio" id="tab-2" name="tabby-tabs">
			<label for="tab-2">Itsetuntemus</label>
			<div class="tabby-content">

			</div>
		</div>

		<div onClick="valitut()" class="tabby-tab">	
			<input type="radio" id="tab-3" name="tabby-tabs" checked>
			<label for="tab-3">Työvalmennus</label>	
			<div class="tabby-content">

    
			<div id="svgs1" class="hero-image1"></div>	
			<table>
			<tr>
			<td>
			<div id="chart" class="hero-image"></div>
			</td>
			<td>
			<div id="stable"></div>
			</td>
			</tr>
			</table>
			</div>
		</div>

		<div class="tabby-tab">
			<input type="radio" id="tab-4" name="tabby-tabs">
			<label for="tab-4">Osallisuusvalmennus</label>
			<div class="tabby-content">

			</div>
		</div>
	</div>
  <button onclick="tarppi();">Tallenna SVG</button>
 
<script>
var tpsum = [];
var period_a = 2016;
var data = [];

/*
var lista1 = [];
var lista2 = [];
var lista3 = [];
var lista4 = [];
var lista5 = [];
var lista6 = [];
var lista7 = [];
var lista8 = [];

//	https://docs.google.com/spreadsheets/d/1_Q1OdE6zVCV4t2_anGZFYlMw1JLCu8LTnGPtZbog1dc/gviz/tq?tqx=out:json&tq&gid=0;

var id = '1_Q1OdE6zVCV4t2_anGZFYlMw1JLCu8LTnGPtZbog1dc';
var gid = '2129349976';
var url = 'https://docs.google.com/spreadsheets/d/'+id+'/gviz/tq?tqx=out:json&tq&gid='+gid;
fetch(url)
  .then(response => response.text())
  .then(data => document.getElementById("json").innerHTML=myItems(data.slice(47, -2)));

function myItems(jsonString){
var r0,r1,r2,r3,r4,r5;
  var json = JSON.parse(jsonString);
  var counter = 0;

  json.table.rows.forEach(ligne => {
  r0 = json.table.rows[counter].c[0].v;
  r1 = json.table.rows[counter].c[1].v;
  r2 = json.table.rows[counter].c[2].v;
  r3 = json.table.rows[counter].c[3].v;
  r4 = json.table.rows[counter].c[4].v;
  r5 = json.table.rows[counter].c[5].v;
//console.log(r0,r1,r2,r3);

 var myObj = JSON.parse('{"groupa":"'+r0+'","groupb":"'+r1+'","groupc":"'+r2+'","text":"'+r3+'","size":"'+r4+'","choice":"'+r5+'"}'); 
 if(r0 === 1) lista1.push(myObj)
 if(r0 === 2) lista2.push(myObj)
 if(r0 === 3) lista3.push(myObj)
 if(r0 === 4) lista4.push(myObj)
 if(r0 === 5) lista5.push(myObj)
 if(r0 === 6) lista6.push(myObj)
 if(r0 === 7) lista7.push(myObj)
 if(r0 === 8) lista8.push(myObj)
 
  counter += 1;
    });
/console.log(lista4);
}
*/
    setTimeout(doSomething, 100);

function doSomething() {
   //do whatever you want here
listaus();
    
    setupSlip(document.getElementById('demo1'));
    setupSlip(document.getElementById('demo2'));
    setupSlip(document.getElementById('demo3'));
    setupSlip(document.getElementById('demo4'));

}


const lista1 = [{"groupa":"1","groupb":"271","groupc":"0.1","text":"Työnhakuoppaat","size":"2","choice":"0"},{"groupa":"1","groupb":"272","groupc":"0.8000000000000002","text":"Työelämätietoisuus","size":"4","choice":"0"},{"groupa":"1","groupb":"274","groupc":"0.7","text":"Ammatinvalintatestit","size":"5","choice":"0"},{"groupa":"1","groupb":"278","groupc":"0.6","text":"Itsetuntemustestit","size":"4","choice":"0"},{"groupa":"1","groupb":"281","groupc":"0.5","text":"Soveltuvuustestit","size":"3","choice":"0"},{"groupa":"1","groupb":"275","groupc":"0.8","text":"Työnhakumateriaalit","size":"7","choice":"0"},{"groupa":"1","groupb":"280","groupc":"0.4","text":"Työmarkkinatietous","size":"6","choice":"0"},{"groupa":"1","groupb":"280","groupc":"0.8","text":"Työpaikkailmoitukset","size":"7","choice":"0"},{"groupa":"1","groupb":"302","groupc":"0.3","text":"Työnhakumessut","size":"2","choice":"0"},{"groupa":"1","groupb":"305","groupc":"0.1","text":"Työnhakupalvelut","size":"5","choice":"0"},{"groupa":"1","groupb":"310","groupc":"0.3","text":"Työnhakuprosessituki","size":"3","choice":"0"},{"groupa":"1","groupb":"310","groupc":"0.3","text":"Työnhakuneuvonta","size":"2","choice":"0"},{"groupa":"1","groupb":"326","groupc":"0.2","text":"Työnhakukoulutuspalvelut","size":"4","choice":"0"},{"groupa":"1","groupb":"335","groupc":"0.6","text":"Työnhakukurssit","size":"1","choice":"0"},{"groupa":"1","groupb":"336","groupc":"0.5","text":"Työpaikkailmoitusseuranta","size":"4","choice":"0"},{"groupa":"1","groupb":"338","groupc":"0.4","text":"Toimialatuntemus","size":"5","choice":"0"},{"groupa":"1","groupb":"340","groupc":"0.5","text":"Työhakuseuranta","size":"4","choice":"0"},{"groupa":"1","groupb":"344","groupc":"0.4","text":"Ammattiverkostot","size":"7","choice":"0"},{"groupa":"1","groupb":"350","groupc":"0.7","text":"Työnhakijaverkostot","size":"4","choice":"0"},{"groupa":"1","groupb":"358","groupc":"0.4","text":"Ammattialatuntemus","size":"3","choice":"0"},{"groupa":"1","groupb":"359","groupc":"0.4","text":"Työnantajakontaktit","size":"8","choice":"0"}];

const lista2 = [{"groupa":"2","groupb":"15","groupc":"0.1","text":"Työmoraali","size":"2","choice":"0"},{"groupa":"2","groupb":"34","groupc":"0.1","text":"Innovaatiokyky","size":"2","choice":"0"},{"groupa":"2","groupb":"61","groupc":"0.1","text":"Markkinointitaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"64","groupc":"0.1","text":"Tauottaminen","size":"1","choice":"0"},{"groupa":"2","groupb":"73","groupc":"0.1","text":"Ongelmanratkaisutaidot","size":"2","choice":"0"},{"groupa":"2","groupb":"79","groupc":"0.1","text":"Analyysitaidot","size":"3","choice":"0"},{"groupa":"2","groupb":"3","groupc":"0.1","text":"Oma-aloitteisuus","size":"4","choice":"0"},{"groupa":"2","groupb":"18","groupc":"0.1","text":"Ammattimaisuus","size":"5","choice":"0"},{"groupa":"2","groupb":"43","groupc":"0.1","text":"Empatiakyky","size":"4","choice":"0"},{"groupa":"2","groupb":"53","groupc":"0.1","text":"Sopeutumiskyky","size":"5","choice":"0"},{"groupa":"2","groupb":"24","groupc":"0.2","text":"Huolellisuus","size":"5","choice":"0"},{"groupa":"2","groupb":"56","groupc":"0.2","text":"Tunneäly","size":"4","choice":"0"},{"groupa":"2","groupb":"63","groupc":"0.2","text":"Myyntitaidot","size":"5","choice":"0"},{"groupa":"2","groupb":"6","groupc":"0.2","text":"Tarkkuus","size":"3","choice":"0"},{"groupa":"2","groupb":"12","groupc":"0.2","text":"Asiakaslähtöisyys","size":"4","choice":"0"},{"groupa":"2","groupb":"31","groupc":"0.2","text":"Oppimiskyky","size":"4","choice":"0"},{"groupa":"2","groupb":"46","groupc":"0.2","text":"Itsetuntemus","size":"4","choice":"0"},{"groupa":"2","groupb":"59","groupc":"0.2","text":"Yhteistyökyky","size":"4","choice":"0"},{"groupa":"2","groupb":"65","groupc":"0.2","text":"Aikataulutustaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"89","groupc":"0.2","text":"Esimiestaidot","size":"3","choice":"0"},{"groupa":"2","groupb":"17","groupc":"0.3","text":"Palvelualttius","size":"3","choice":"0"},{"groupa":"2","groupb":"27","groupc":"0.3","text":"Itsekuri","size":"4","choice":"0"},{"groupa":"2","groupb":"37","groupc":"0.3","text":"Analyyttisyys","size":"4","choice":"0"},{"groupa":"2","groupb":"66","groupc":"0.3","text":"Asiakaspalvelutaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"74","groupc":"0.3","text":"Suunnittelutaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"78","groupc":"0.3","text":"Ammattitaito","size":"2","choice":"0"},{"groupa":"2","groupb":"86","groupc":"0.3","text":"Työnhakutaidot","size":"3","choice":"0"},{"groupa":"2","groupb":"5","groupc":"0.3","text":"Kriittisyys","size":"4","choice":"0"},{"groupa":"2","groupb":"76","groupc":"0.3","text":"Teknologiataidot","size":"4","choice":"0"},{"groupa":"2","groupb":"76","groupc":"0.3","text":"Ammattipätevyys","size":"4","choice":"0"},{"groupa":"2","groupb":"82","groupc":"0.3","text":"Tunnehallintataidot","size":"5","choice":"0"},{"groupa":"2","groupb":"75","groupc":"0.4","text":"Itsearviointitaidot","size":"6","choice":"0"},{"groupa":"2","groupb":"77","groupc":"0.4","text":"Projektinhallinta","size":"2","choice":"0"},{"groupa":"2","groupb":"78","groupc":"0.4","text":"Viestintätaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"8","groupc":"0.4","text":"Positiivisuus","size":"5","choice":"0"},{"groupa":"2","groupb":"9","groupc":"0.4","text":"Asiakaskeskeisyys","size":"3","choice":"0"},{"groupa":"2","groupb":"35","groupc":"0.4","text":"Työkyky","size":"2","choice":"0"},{"groupa":"2","groupb":"75","groupc":"0.4","text":"Resurssihallintataidot","size":"2","choice":"0"},{"groupa":"2","groupb":"81","groupc":"0.4","text":"Verkostoitumistaidot","size":"3","choice":"0"},{"groupa":"2","groupb":"84","groupc":"0.4","text":"Tavoitteenasettamistaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"21","groupc":"0.4","text":"Työetiikka","size":"6","choice":"0"},{"groupa":"2","groupb":"52","groupc":"0.4","text":"Joustavuus","size":"5","choice":"0"},{"groupa":"2","groupb":"67","groupc":"0.5","text":"Delegointitaidot","size":"2","choice":"0"},{"groupa":"2","groupb":"85","groupc":"0.5","text":"Ajanhallintataidot","size":"4","choice":"0"},{"groupa":"2","groupb":"68","groupc":"0.5","text":"Etätyötaidot","size":"5","choice":"0"},{"groupa":"2","groupb":"79","groupc":"0.5","text":"Vuorovaikutustaidot","size":"3","choice":"0"},{"groupa":"2","groupb":"80","groupc":"0.5","text":"Tietotekniikkataidot","size":"5","choice":"0"},{"groupa":"2","groupb":"81","groupc":"0.5","text":"Työkokemus","size":"2","choice":"0"},{"groupa":"2","groupb":"86","groupc":"0.5","text":"Yrittäjyystaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"58","groupc":"0.5","text":"Terveys","size":"5","choice":"0"},{"groupa":"2","groupb":"11","groupc":"0.6","text":"Suunnitelmallisuus","size":"3","choice":"0"},{"groupa":"2","groupb":"49","groupc":"0.6","text":"Paineensietokyky","size":"4","choice":"0"},{"groupa":"2","groupb":"69","groupc":"0.6","text":"Johtajuustaidot","size":"5","choice":"0"},{"groupa":"2","groupb":"74","groupc":"0.6","text":"Ryhmätyötaidot","size":"2","choice":"0"},{"groupa":"2","groupb":"32","groupc":"0.6","text":"Kärsivällisyys","size":"5","choice":"0"},{"groupa":"2","groupb":"35","groupc":"0.6","text":"Itseluottamus","size":"4","choice":"0"},{"groupa":"2","groupb":"38","groupc":"0.6","text":"Stressinhallinta","size":"1","choice":"0"},{"groupa":"2","groupb":"70","groupc":"0.6","text":"Johtamistaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"77","groupc":"0.6","text":"Päätöksentekotaidot","size":"3","choice":"0"},{"groupa":"2","groupb":"83","groupc":"0.6","text":"Tiimityötaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"38","groupc":"0.7","text":"Itsenäisyys","size":"6","choice":"0"},{"groupa":"2","groupb":"71","groupc":"0.7","text":"Kommunikointitaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"85","groupc":"0.7","text":"Työhaastattelutaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"55","groupc":"0.7","text":"Motivaatio","size":"5","choice":"0"},{"groupa":"2","groupb":"83","groupc":"0.7","text":"Digitaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"82","groupc":"0.7","text":"Työyhteisötaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"41","groupc":"0.7","text":"Luovuus","size":"2","choice":"0"},{"groupa":"2","groupb":"40","groupc":"0.8000000000000002","text":"Tyytyväisyys","size":"4","choice":"0"},{"groupa":"2","groupb":"44","groupc":"0.8000000000000002","text":"Mukautuvuus","size":"4","choice":"0"},{"groupa":"2","groupb":"87","groupc":"0.8000000000000002","text":"Konfliktiratkaisutaidot","size":"2","choice":"0"},{"groupa":"2","groupb":"87","groupc":"0.8000000000000002","text":"Kuuntelutaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"62","groupc":"0.8000000000000002","text":"Priorisointitaidot","size":"4","choice":"0"},{"groupa":"2","groupb":"72","groupc":"0.8000000000000002","text":"Konfliktihallintataidot","size":"4","choice":"0"},{"groupa":"2","groupb":"47","groupc":"0.8000000000000002","text":"Itseohjautuvuus","size":"5","choice":"0"},{"groupa":"2","groupb":"88","groupc":"0.8000000000000002","text":"Motivointitaidot","size":"2","choice":"0"},{"groupa":"2","groupb":"50","groupc":"0.8000000000000002","text":"Itsevarmuus","size":"5","choice":"0"},{"groupa":"2","groupb":"80","groupc":"0.8000000000000002","text":"Neuvottelutaidot","size":"2","choice":"0"},{"groupa":"2","groupb":"84","groupc":"0.8000000000000002","text":"Esiintymistaidot","size":"1","choice":"0"},{"groupa":"2","groupb":"88","groupc":"0.8000000000000002","text":"Organisointitaidot","size":"4","choice":"0"}];

const lista3 = [{"groupa":"3","groupb":"91","groupc":"0.6","text":"Rekrytointiprosessi","size":"6","choice":"0"},{"groupa":"3","groupb":"93","groupc":"0.5","text":"Koulutusohjaus","size":"4","choice":"0"},{"groupa":"3","groupb":"94","groupc":"0.7","text":"Kykytestit","size":"3","choice":"0"},{"groupa":"3","groupb":"96","groupc":"0.4","text":"Ammattikoulutus","size":"5","choice":"0"},{"groupa":"3","groupb":"97","groupc":"0.1","text":"Työvalmennusohjelma","size":"3","choice":"0"},{"groupa":"3","groupb":"100","groupc":"0.2","text":"Ansioluettelo","size":"3","choice":"0"},{"groupa":"3","groupb":"103","groupc":"0.3","text":"Portfolio","size":"4","choice":"0"},{"groupa":"3","groupb":"104","groupc":"0.4","text":"Koulutushakusuunnitelma","size":"4","choice":"0"},{"groupa":"3","groupb":"105","groupc":"0.3","text":"Työnhakijaprofiili","size":"2","choice":"0"},{"groupa":"3","groupb":"105","groupc":"0.5","text":"Työhakemus","size":"4","choice":"0"},{"groupa":"3","groupb":"106","groupc":"0.5","text":"Työllistämissuunnitelma","size":"4","choice":"0"},{"groupa":"3","groupb":"112","groupc":"0.5","text":"Työtoiminta ","size":"5","choice":"0"},{"groupa":"3","groupb":"115","groupc":"0.4","text":"Vapaaehtoistoiminta","size":"6","choice":"0"},{"groupa":"3","groupb":"108","groupc":"0.5","text":"Ammattitaitoprofiili","size":"3","choice":"0"},{"groupa":"3","groupb":"109","groupc":"0.7","text":"Työnhakusuunnitelma","size":"4","choice":"0"},{"groupa":"3","groupb":"111","groupc":"0.6","text":"Uraohjaus","size":"3","choice":"0"},{"groupa":"3","groupb":"112","groupc":"0.6","text":"Työllistymissuunnitelma","size":"4","choice":"0"},{"groupa":"3","groupb":"112","groupc":"0.8000000000000002","text":"Työvalmennusuunnitelma","size":"4","choice":"0"},{"groupa":"3","groupb":"114","groupc":"0.6","text":"Työnhakuportfolio","size":"4","choice":"0"},{"groupa":"3","groupb":"114","groupc":"0.8000000000000002","text":"Uravaihtomahdollisuudet","size":"3","choice":"0"},{"groupa":"3","groupb":"116","groupc":"0.7","text":"Työnhakuprofiili","size":"4","choice":"0"},{"groupa":"3","groupb":"117","groupc":"0.6","text":"Uudelleenkoulutus","size":"2","choice":"0"},{"groupa":"3","groupb":"118","groupc":"0.7","text":"Työnhakusivustot","size":"4","choice":"0"},{"groupa":"3","groupb":"119","groupc":"0.5","text":"Työvoimakoulutus","size":"4","choice":"0"},{"groupa":"3","groupb":"121","groupc":"0.3","text":"Haastattelutekniikat","size":"5","choice":"0"},{"groupa":"3","groupb":"124","groupc":"0.8000000000000002","text":"Koulutusmahdollisuudet","size":"4","choice":"0"},{"groupa":"3","groupb":"127","groupc":"0.8000000000000002","text":"Työllistämisstrategiat","size":"4","choice":"0"},{"groupa":"3","groupb":"131","groupc":"0.1","text":"Työllistymisstrategiat","size":"4","choice":"0"},{"groupa":"3","groupb":"134","groupc":"0.2","text":"Työllistymisvalmennus","size":"4","choice":"0"},{"groupa":"3","groupb":"137","groupc":"0.3","text":"Työurasuunnittelu","size":"4","choice":"0"},{"groupa":"3","groupb":"151","groupc":"0.1","text":"Työhaastatteluharjoitukset","size":"4","choice":"0"},{"groupa":"3","groupb":"154","groupc":"0.3","text":"Ammattiohjaus","size":"4","choice":"0"},{"groupa":"3","groupb":"157","groupc":"0.4","text":"Tavoiteasettelu","size":"4","choice":"0"},{"groupa":"3","groupb":"160","groupc":"0.4","text":"Työnhakuvalmennus","size":"4","choice":"0"},{"groupa":"3","groupb":"163","groupc":"0.2","text":"Työnhakuwebinaari","size":"4","choice":"0"},{"groupa":"3","groupb":"166","groupc":"0.2","text":"Työnhakustrategiat","size":"3","choice":"0"}];
  
var lista4 = [{"groupa":"4","groupb":"180","groupc":"0.7","text":"Työkokeilu","size":"4","choice":"0"},{"groupa":"4","groupb":"181","groupc":"0.6","text":"Työharjoittelu","size":"4","choice":"0"},{"groupa":"4","groupb":"182","groupc":"0.1","text":"Työnantajatuntemus","size":"4","choice":"0"},{"groupa":"4","groupb":"188","groupc":"0.5","text":"Työhönvalmennus","size":"4","choice":"0"},{"groupa":"4","groupb":"184","groupc":"0.1","text":"Työhaastattelu","size":"4","choice":"0"},{"groupa":"4","groupb":"185","groupc":"0.2","text":"Rekrytointiprosessi","size":"4","choice":"0"},{"groupa":"4","groupb":"185","groupc":"0.8000000000000002","text":"Suositukset","size":"3","choice":"0"},{"groupa":"4","groupb":"186","groupc":"0.5","text":"Työpaikkakäynnit","size":"4","choice":"0"},{"groupa":"4","groupb":"186","groupc":"0.7","text":"Soveltuvuusarviointi","size":"4","choice":"0"},{"groupa":"4","groupb":"187","groupc":"0.7","text":"Työhaastattelukysymykset","size":"4","choice":"0"},{"groupa":"4","groupb":"190","groupc":"0.2","text":"Valintakriteerit","size":"4","choice":"0"},{"groupa":"4","groupb":"190","groupc":"0.5","text":"Työpaikkatutustumisjaksot","size":"4","choice":"0"},{"groupa":"4","groupb":"190","groupc":"0.8","text":"Työtodistukset","size":"5","choice":"0"},{"groupa":"4","groupb":"195","groupc":"0.2","text":"Koeaika","size":"4","choice":"0"},{"groupa":"4","groupb":"196","groupc":"0.8000000000000002","text":"Työtarjous","size":"4","choice":"0"},{"groupa":"4","groupb":"200","groupc":"0.6","text":"Henkilöstövuokraus","size":"4","choice":"0"},{"groupa":"4","groupb":"205","groupc":"0.8000000000000002","text":"Työtehtävät","size":"4","choice":"0"},{"groupa":"4","groupb":"216","groupc":"0.2","text":"Oppisopimus","size":"2","choice":"0"},{"groupa":"4","groupb":"217","groupc":"0.1","text":"Palkkaneuvottelut","size":"5","choice":"0"},{"groupa":"4","groupb":"218","groupc":"0.1","text":"Työsopimus","size":"5","choice":"0"},{"groupa":"4","groupb":"218","groupc":"0.2","text":"Työehdot","size":"5","choice":"0"},{"groupa":"4","groupb":"219","groupc":"0.8000000000000002","text":"Työpaikkavaihto","size":"5","choice":"0"},{"groupa":"4","groupb":"220","groupc":"0.8000000000000002","text":"Palkkaus","size":"5","choice":"0"},{"groupa":"4","groupb":"220","groupc":"0.8000000000000002","text":"Työelämäpelisäännöt","size":"5","choice":"0"},{"groupa":"4","groupb":"222","groupc":"0.8000000000000002","text":"Palkkatuki","size":"5","choice":"0"},{"groupa":"4","groupb":"226","groupc":"0.7","text":"Irtisanoutuminen","size":"4","choice":"0"},{"groupa":"4","groupb":"242","groupc":"0.8000000000000002","text":"Työmatkat","size":"3","choice":"0"},{"groupa":"4","groupb":"246","groupc":"0.6","text":"Työyhteisötuki","size":"4","choice":"0"},{"groupa":"4","groupb":"246","groupc":"0.8000000000000002","text":"Työntekijäedut","size":"4","choice":"0"},{"groupa":"4","groupb":"248","groupc":"0.7","text":"Työelämälainsäädäntö","size":"5","choice":"0"},{"groupa":"4","groupb":"252","groupc":"0.4","text":"Työkaverit","size":"5","choice":"0"},{"groupa":"4","groupb":"252","groupc":"0.7","text":"Työhyvinvointi","size":"4","choice":"0"},{"groupa":"4","groupb":"253","groupc":"0.3","text":"Työilmapiiri","size":"5","choice":"0"},{"groupa":"4","groupb":"256","groupc":"0.2","text":"Työssäoppiminen","size":"5","choice":"0"},{"groupa":"4","groupb":"256","groupc":"0.2","text":"Työsuojeluasiat","size":"4","choice":"0"},{"groupa":"4","groupb":"257","groupc":"0.1","text":"Työssäjaksaminen","size":"5","choice":"0"},{"groupa":"4","groupb":"258","groupc":"0.1","text":"Työpaikkakulttuuri","size":"4","choice":"0"}];

var varinumero = 0;
var round = 0;
var laskuri = 0;
var clouds = ["#wordcloud1","#wordcloud2","#wordcloud3","#wordcloud4","#wordcloud5","#wordcloud6","#wordcloud7","#wordcloud8"];
var order = ["demo1","demo2","demo3","demo4"];
var listat = [lista1,lista2,lista3,lista4];
var valitut1 = [];
var valitut2 = [];
var valitut3 = [];
var valitut4 = [];


function valitut() {
var valitut = [];

data = [];
for (var j = 0; j < valitut1.length; j++) {
if(valitut1[j][5] > 0) {
if(valitut1[j][5] > 1) {
data.push([((valitut1[j][1]-90)*6.2831853/-359),0.9,valitut1[j][4],valitut1[j][3]]);
} else {
data.push([((valitut1[j][1]-90)*6.2831853/-359),valitut1[j][2],valitut1[j][4],valitut1[j][3]]);
}
}
}

for (var j = 0; j < valitut2.length; j++) {
if (valitut2[j][5] > 0) {
if (valitut2[j][5] > 1) {
data.push([((valitut2[j][1]-90)*6.2831853/-359),0.9,valitut2[j][4],valitut2[j][3]]);
} else {
data.push([((valitut2[j][1]-90)*6.2831853/-359),valitut2[j][2],valitut2[j][4],valitut2[j][3]]);
}
}
}

for (var j = 0; j < valitut3.length; j++) {
if (valitut3[j][5] > 0) {
if (valitut3[j][5] > 1) {
data.push([((valitut3[j][1]-90)*6.2831853/-359),0.9,valitut3[j][4],valitut3[j][3]]);
} else {
data.push([((valitut3[j][1]-90)*6.2831853/-359),valitut3[j][2],valitut3[j][4],valitut3[j][3]]);
}
}
}

for (var j = 0; j < valitut4.length; j++) {
if (valitut4[j][5] > 0) {
if (valitut4[j][5] > 1) {
data.push([((valitut4[j][1]-90)*6.2831853/-359),0.9,valitut4[j][4],valitut4[j][3]]);
} else {
data.push([((valitut4[j][1]-90)*6.2831853/-359),valitut4[j][2],valitut4[j][4],valitut4[j][3]]);
}
}
}
polar(data);
}

function pilvessa() {

var listaId = listat[laskuri]; 
var cloudId = clouds[laskuri];

const marginTop = 0, 
  marginRight = 0,
  marginBottom = 0,
  marginLeft = 0,
  width = 640,
  height = 400,
  maxWords = 250, 
  fontFamily = "sans-serif",
  fontScale = 15,
  padding = 0,
  rotate = 0;


    const leveys = 800;
    const korkeus = 400;

    const layout = d3.layout.cloud()
      .size([leveys, korkeus])
      .words(listaId)
      .padding(padding)
      .rotate(() => rotate)
      .font(fontFamily)
      .fontSize(d => Math.sqrt(d.size) * fontScale)
      .on("end", piirra);

    layout.start();

    function piirra(sanat) {
      //const svg = d3.select("#word-cloud")
      const svg = d3.select(cloudId)
        .attr("width", leveys)
        .attr("height", korkeus);

      const g = svg.append("g")
        .attr("transform", `translate(${leveys / 2}, ${korkeus / 2})`);

      const tekstit = g.selectAll("text")
        .data(sanat)
        .enter()
        .append("text")
        .style("font-size", d => `${d.size}px`)
        .style("font-family", "Arial")
        .attr("text-anchor", "middle")
        .attr("transform", d => `translate(${d.x}, ${d.y})rotate(${d.rotate})`)
        .text(d => d.text)
        .style("cursor", "pointer")
        .style("fill", "black")
        .each(function (d) {
          d.vari = 0; 
        })
        .on("click", function (d) {
          d.vari = (d.vari + 1) % 3; 
          d3.select(this).style("fill", getColor(d.vari));

//console.log(cloudId);
if(cloudId === clouds[0]) {
round = 0;
let riviIndeksi = valitut1.findIndex(rivi => rivi.includes(d.text));
//console.log(d.vari);
//console.log(valitut1);
if (riviIndeksi !== -1) {
  valitut1[riviIndeksi][5] = d.vari;
  }else{
  valitut1.push([d.groupa,d.groupb,d.groupc,d.text,d.size,d.vari]);  
}
}

if(cloudId === clouds[1]) {
round = 1;
let riviIndeksi = valitut2.findIndex(rivi => rivi.includes(d.text));
if (riviIndeksi !== -1) {
  valitut2[riviIndeksi][5] = d.vari;
  }else{
  valitut2.push([d.groupa,d.groupb,d.groupc,d.text,d.size,d.vari]);  
}
}

if(cloudId === clouds[2]) {
round = 2;
let riviIndeksi = valitut3.findIndex(rivi => rivi.includes(d.text));
if (riviIndeksi !== -1) {
  valitut3[riviIndeksi][5] = d.vari;
  }else{
  valitut3.push([d.groupa,d.groupb,d.groupc,d.text,d.size,d.vari]);  
}
}

if(cloudId === clouds[3]) {
round = 3;
let riviIndeksi = valitut4.findIndex(rivi => rivi.includes(d.text));
if (riviIndeksi !== -1) {
  valitut4[riviIndeksi][5] = d.vari;
  }else{
  valitut4.push([d.groupa,d.groupb,d.groupc,d.text,d.size,d.vari]);  
}
}

vihreat();
          
});

function getColor(varinumero) {
        if (varinumero === 0) {
          return "black";
        } else if (varinumero === 1) {
          return "green";
        } else if (varinumero === 2) {
          return "red";
        }
      }
    }
    
}//pilvessa 


function vihreat(){

if(round===0) {
var table = '';
var montako = valitut1.length;
for (var r = 0; r < montako; r++) {
if(valitut1[r][5] === 1) table += '<li class="demo-no-swipe"><span class="instant" style="color:green;">' + valitut1[r][3] + ' ' + valitut1[r][5] + '</span></li>'
if(valitut1[r][5] === 2) table += '<li class="demo-no-swipe"><span class="instant" style="color:red;">' + valitut1[r][3] + ' ' + valitut1[r][5] + '</span></li>'
setupSlip(document.getElementById('demo1'));
}
}

if(round===1) {
var table = '';
var montako = valitut2.length;
for (var r = 0; r < montako; r++) {
if(valitut2[r][5] === 1) table += '<li class="demo-no-swipe"><span class="instant" style="color:green;">' + valitut2[r][3] + ' ' + valitut2[r][5] + '</span></li>'
if(valitut2[r][5] === 2) table += '<li class="demo-no-swipe"><span class="instant" style="color:red;">' + valitut2[r][3] + ' ' + valitut2[r][5] + '</span></li>'
setupSlip(document.getElementById('demo2'));
}
}

if(round===2) {
var table = '';
var montako = valitut3.length;
for (var r = 0; r < montako; r++) {
if(valitut3[r][5] === 1) table += '<li class="demo-no-swipe"><span class="instant" style="color:green;">' + valitut3[r][3] + ' ' + valitut3[r][5] + '</span></li>'
if(valitut3[r][5] === 2) table += '<li class="demo-no-swipe"><span class="instant" style="color:red;">' + valitut3[r][3] + ' ' + valitut3[r][5] + '</span></li>'
setupSlip(document.getElementById('demo3'));
}
}

if(round===3) {
var table = '';
var montako = valitut4.length;
for (var r = 0; r < montako; r++) {
if(valitut4[r][5] === 1) table += '<li class="demo-no-swipe"><span class="instant" style="color:green;">' + valitut4[r][3] + ' ' + valitut4[r][5] + '</span></li>'
if(valitut4[r][5] === 2) table += '<li class="demo-no-swipe"><span class="instant" style="color:red;">' + valitut4[r][3] + ' ' + valitut4[r][5] + '</span></li>'
setupSlip(document.getElementById('demo4'));
}
}

document.getElementById(order[round]).innerHTML = table;
}


function listaus() {
const listElement = document.querySelector('.slider ul.list');
const intersectionObserverElements = document.querySelectorAll('.slider > ul.slider-items > li');
const dots = document.querySelectorAll('.slider > ul.slider-dots > li');

function setActiveDot(selectedIndex) {
	dots.forEach((dot, index) => {
		dot.classList.remove('active');
		if (index === selectedIndex) {
			dot.classList.add('active');
		}
	});
}

let options = {
	root: listElement,
	rootMargin: '0px',
	threshold: [1]
}

let callback = (entries, observer) => {
	entries.forEach(entry => {
		if (entry.intersectionRatio === 1) {
			let dataId = `${entry.target.getAttribute('data-id')}`;
			setActiveDot(parseInt(dataId));
		}
	});
};

let observer = new IntersectionObserver(callback, options);

intersectionObserverElements.forEach((card) => {
	observer.observe(card);
});


  pilvessa();
    laskuri +=1;
    pilvessa();
    laskuri +=1;
    pilvessa();
    laskuri +=1;
    pilvessa();
  
}

window['Slip'] = (function(){
    'use strict';

    var accessibilityDefaults = {
        // Set values to false if you don't want Slip to manage them
        container: {
            role: "listbox",
            tabIndex: 0,
            focus: false, // focuses after drop
        },
        items: {
            role: "option", // If "option" flattens items, try "group":
            // https://www.marcozehe.de/2013/03/08/sometimes-you-have-to-use-illegal-wai-aria-to-make-stuff-work/
            tabIndex: -1, // 0 will make every item tabbable, which isn't always useful
            focus: false, // focuses when dragging
        },
    };

    var damnYouChrome = /Chrome\/[3-5]/.test(navigator.userAgent); // For bugs that can't be programmatically detected :( Intended to catch all versions of Chrome 30-40
    var needsBodyHandlerHack = damnYouChrome; // Otherwise I _sometimes_ don't get any touchstart events and only clicks instead.

    /* When dragging elements down in Chrome (tested 34-37) dragged element may appear below stationary elements.
       Looks like WebKit bug #61824, but iOS Safari doesn't have that problem. */
    var compositorDoesNotOrderLayers = damnYouChrome;

    // -webkit-mess
    var testElementStyle = document.createElement('div').style;

    var transitionJSPropertyName = "transition" in testElementStyle ? "transition" : "webkitTransition";
    var transformJSPropertyName = "transform" in testElementStyle ? "transform" : "webkitTransform";
    var transformCSSPropertyName = transformJSPropertyName === "webkitTransform" ? "-webkit-transform" : "transform";
    var userSelectJSPropertyName = "userSelect" in testElementStyle ? "userSelect" : "webkitUserSelect";

    testElementStyle[transformJSPropertyName] = 'translateZ(0)';
    var hwLayerMagicStyle = testElementStyle[transformJSPropertyName] ? 'translateZ(0) ' : '';
    var hwTopLayerMagicStyle = testElementStyle[transformJSPropertyName] ? 'translateZ(1px) ' : '';
    testElementStyle = null;

    var globalInstances = 0;
    var attachedBodyHandlerHack = false;
    var nullHandler = function(){};

    function Slip(container, options) {
        if ('string' === typeof container) container = document.querySelector(container);
        if (!container || !container.addEventListener) throw new Error("Please specify DOM node to attach to");

        if (!this || this === window) return new Slip(container, options);

        this.options = options = options || {};
        this.options.keepSwipingPercent = options.keepSwipingPercent || 0;
        this.options.minimumSwipeVelocity = options.minimumSwipeVelocity || 1;
        this.options.minimumSwipeTime = options.minimumSwipeTime || 110;
        this.options.ignoredElements = options.ignoredElements || [];
        this.options.accessibility = options.accessibility || accessibilityDefaults;
        this.options.accessibility.container = options.accessibility.container || accessibilityDefaults.container;

        this.options.accessibility.container.role = options.accessibility.container.role !== undefined ?
            options.accessibility.container.role :
            accessibilityDefaults.container.role;

        this.options.accessibility.container.tabIndex = options.accessibility.container.tabIndex !== undefined ?
            options.accessibility.container.tabIndex :
            accessibilityDefaults.container.tabIndex;

        this.options.accessibility.container.focus = options.accessibility.container.focus !== undefined ?
            options.accessibility.container.focus :
            accessibilityDefaults.container.focus;

        this.options.accessibility.items = options.accessibility.items || accessibilityDefaults.items;

        this.options.accessibility.items.role = options.accessibility.items.role !== undefined ?
            options.accessibility.items.role :
            accessibilityDefaults.items.role;

        this.options.accessibility.items.tabIndex = options.accessibility.items.tabIndex !== undefined ?
            options.accessibility.items.tabIndex :
            accessibilityDefaults.items.tabIndex;

        this.options.accessibility.items.role = options.accessibility.items.focus !== undefined ?
            options.accessibility.items.focus :
            accessibilityDefaults.items.focus;

        if (!Array.isArray(this.options.ignoredElements)) throw new Error("ignoredElements must be an Array");

        // Functions used for as event handlers need usable `this` and must not change to be removable
        this.cancel = this.setState.bind(this, this.states.idle);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchMove = this.onTouchMove.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
        this.onSelection = this.onSelection.bind(this);
        this.onContainerFocus = this.onContainerFocus.bind(this);

        this.setState(this.states.idle);
        this.attach(container);
    }

    function getTransform(node) {
        var transform = node.style[transformJSPropertyName];
        if (transform) {
            return {
                value: transform,
                original: transform,
            };
        }

        if (window.getComputedStyle) {
            var style = window.getComputedStyle(node).getPropertyValue(transformCSSPropertyName);
            if (style && style !== 'none') return {value:style, original:''};
        }
        return {value:'', original:''};
    }

    function findIndex(target, nodes) {
      var originalIndex = 0;
      var listCount = 0;

      for (var i=0; i < nodes.length; i++) {
        if (nodes[i].nodeType === 1) {
          listCount++;
          if (nodes[i] === target.node) {
            originalIndex = listCount-1;
          }
        }
      }

      return originalIndex;
    }

    // All functions in states are going to be executed in context of Slip object
    Slip.prototype = {

        container: null,
        options: {},
        state: null,

        target: null, // the tapped/swiped/reordered node with height and backed up styles

        usingTouch: false, // there's no good way to detect touchscreen preference other than receiving a touch event (really, trust me).
        mouseHandlersAttached: false,

        startPosition: null, // x,y,time where first touch began
        latestPosition: null, // x,y,time where the finger is currently
        previousPosition: null, // x,y,time where the finger was ~100ms ago (for velocity calculation)

        canPreventScrolling: false,

        states: {
            idle: function idleStateInit() {
                this.removeMouseHandlers();
                if (this.target) {
                    this.target.node.style.willChange = '';
                    this.target = null;
                }
                this.usingTouch = false;

                return {
                    allowTextSelection: true,
                };
            },

            undecided: function undecidedStateInit() {
                this.target.height = this.target.node.offsetHeight;
                this.target.node.style.willChange = transformCSSPropertyName;
                this.target.node.style[transitionJSPropertyName] = '';

                if (!this.dispatch(this.target.originalTarget, 'beforewait')) {
                    if (this.dispatch(this.target.originalTarget, 'beforereorder')) {
                        this.setState(this.states.reorder);
                    }
                } else {
                    var holdTimer = setTimeout(function(){
                        var move = this.getAbsoluteMovement();
                        if (this.canPreventScrolling && move.x < 15 && move.y < 25) {
                            if (this.dispatch(this.target.originalTarget, 'beforereorder')) {
                                this.setState(this.states.reorder);
                            }
                        }
                    }.bind(this), 300);
                }

                return {
                    leaveState: function() {
                        clearTimeout(holdTimer);
                    },

                    onMove: function() {
                        var move = this.getAbsoluteMovement();

                        if (move.x > 20 && move.y < Math.max(100, this.target.height)) {
                            if (this.dispatch(this.target.originalTarget, 'beforeswipe', {directionX: move.directionX, directionY: move.directionY})) {
                                this.setState(this.states.swipe);
                                return false;
                            } else {
                                this.setState(this.states.idle);
                            }
                        }
                        if (move.y > 20) {
                            this.setState(this.states.idle);
                        }

                        // Chrome likes sideways scrolling :(
                        if (move.x > move.y*1.2) return false;
                    },

                    onLeave: function() {
                        this.setState(this.states.idle);
                    },

                    onEnd: function() {
                        var allowDefault = this.dispatch(this.target.originalTarget, 'tap');
                        this.setState(this.states.idle);
                        return allowDefault;
                    },
                };
            },

            reorder: function reorderStateInit() {
                if (this.target.node.focus && this.options.accessibility.items.focus) {
                    this.target.node.focus();
                }

                this.target.height = this.target.node.offsetHeight;

                var nodes;
                if (this.options.ignoredElements.length) {
                    var container = this.container;
                    var query = container.tagName.toLowerCase();
                    if (container.getAttribute('id')) {
                        query = '#' + container.getAttribute('id');
                    } else if (container.classList.length) {
                        query += '.' + container.getAttribute('class').replace(' ', '.');
                    }
                    query += ' > ';
                    this.options.ignoredElements.forEach(function (selector) {
                        query += ':not(' + selector + ')';
                    });
                    try {
                        nodes = container.parentNode.querySelectorAll(query);
                    } catch(err) {
                        if (err instanceof DOMException && err.name === 'SyntaxError')
                            throw new Error('ignoredElements you specified contain invalid query');
                        else
                            throw err;
                    }
                } else {
                    nodes = this.container.childNodes;
                }
                var originalIndex = findIndex(this.target, nodes);
                var mouseOutsideTimer;
                var zero = this.target.node.offsetTop + this.target.height/2;
                var otherNodes = [];
                for(var i=0; i < nodes.length; i++) {
                    if (nodes[i].nodeType != 1 || nodes[i] === this.target.node) continue;
                    var t = nodes[i].offsetTop;
                    nodes[i].style[transitionJSPropertyName] = transformCSSPropertyName + ' 0.2s ease-in-out';
                    otherNodes.push({
                        node: nodes[i],
                        baseTransform: getTransform(nodes[i]),
                        pos: t + (t < zero ? nodes[i].offsetHeight : 0) - zero,
                    });
                }

                this.target.node.classList.add('slip-reordering');
                this.target.node.style.zIndex = '99999';
                this.target.node.style[userSelectJSPropertyName] = 'none';
                if (compositorDoesNotOrderLayers) {
                    // Chrome's compositor doesn't sort 2D layers
                    this.container.style.webkitTransformStyle = 'preserve-3d';
                }

                function onMove() {
                    /*jshint validthis:true */

                    this.updateScrolling();

                    if (mouseOutsideTimer) {
                        // don't care where the mouse is as long as it moves
                        clearTimeout(mouseOutsideTimer); mouseOutsideTimer = null;
                    }

                    var move = this.getTotalMovement();
                    this.target.node.style[transformJSPropertyName] = 'translate(0,' + move.y + 'px) ' + hwTopLayerMagicStyle + this.target.baseTransform.value;

                    var height = this.target.height;
                    otherNodes.forEach(function(o){
                        var off = 0;
                        if (o.pos < 0 && move.y < 0 && o.pos > move.y) {
                            off = height;
                        }
                        else if (o.pos > 0 && move.y > 0 && o.pos < move.y) {
                            off = -height;
                        }
                        // FIXME: should change accelerated/non-accelerated state lazily
                        o.node.style[transformJSPropertyName] = off ? 'translate(0,'+off+'px) ' + hwLayerMagicStyle + o.baseTransform.value : o.baseTransform.original;
                    });
                    return false;
                }

                onMove.call(this);

                return {
                    leaveState: function() {
                        if (mouseOutsideTimer) clearTimeout(mouseOutsideTimer);

                        if (compositorDoesNotOrderLayers) {
                            this.container.style.webkitTransformStyle = '';
                        }

                        if (this.container.focus && this.options.accessibility.container.focus) {
                            this.container.focus();
                        }

                        this.target.node.classList.remove('slip-reordering');
                        this.target.node.style[userSelectJSPropertyName] = '';

                        this.animateToZero(function(target){
                            target.node.style.zIndex = '';
                        });
                        otherNodes.forEach(function(o){
                            o.node.style[transformJSPropertyName] = o.baseTransform.original;
                            o.node.style[transitionJSPropertyName] = ''; // FIXME: animate to new position
                        });
                    },

                    onMove: onMove,

                    onLeave: function() {
                        // don't let element get stuck if mouse left the window
                        // but don't cancel immediately as it'd be annoying near window edges
                        if (mouseOutsideTimer) clearTimeout(mouseOutsideTimer);
                        mouseOutsideTimer = setTimeout(function(){
                            mouseOutsideTimer = null;
                            this.cancel();
                        }.bind(this), 700);
                    },

                    onEnd: function() {
                        var move = this.getTotalMovement();
                        var i, spliceIndex;
                        if (move.y < 0) {
                            for (i=0; i < otherNodes.length; i++) {
                                if (otherNodes[i].pos > move.y) {
                                    break;
                                }
                            }
                            spliceIndex = i;
                        } else {
                            for (i=otherNodes.length-1; i >= 0; i--) {
                                if (otherNodes[i].pos < move.y) {
                                    break;
                                }
                            }
                            spliceIndex = i+1;
                        }

                        this.dispatch(this.target.node, 'reorder', {
                            spliceIndex: spliceIndex,
                            originalIndex: originalIndex,
                            insertBefore: otherNodes[spliceIndex] ? otherNodes[spliceIndex].node : null,
                        });

                        this.setState(this.states.idle);
                        return false;
                    },
                };
            },
        },

        attach: function(container) {
            globalInstances++;
            if (this.container) this.detach();

            // In some cases taps on list elements send *only* click events and no touch events. Spotted only in Chrome 32+
            // Having event listener on body seems to solve the issue (although AFAIK may disable smooth scrolling as a side-effect)
            if (!attachedBodyHandlerHack && needsBodyHandlerHack) {
                attachedBodyHandlerHack = true;
                document.body.addEventListener('touchstart', nullHandler, false);
            }

            this.container = container;

            // Accessibility
            if (false !== this.options.accessibility.container.tabIndex) {
                this.container.tabIndex = this.options.accessibility.container.tabIndex;
            }
            if (this.options.accessibility.container.role) {
                this.container.setAttribute('role', this.options.accessibility.container.role);
            }
            this.setChildNodesRoles();
            this.container.addEventListener('focus', this.onContainerFocus, false);

            this.otherNodes = [];

            // selection on iOS interferes with reordering
            document.addEventListener("selectionchange", this.onSelection, false);

            // cancel is called e.g. when iOS detects multitasking gesture
            this.container.addEventListener('touchcancel', this.cancel, false);
            this.container.addEventListener('touchstart', this.onTouchStart, false);
            this.container.addEventListener('touchmove', this.onTouchMove, false);
            this.container.addEventListener('touchend', this.onTouchEnd, false);
            this.container.addEventListener('mousedown', this.onMouseDown, false);
            // mousemove and mouseup are attached dynamically
        },

        setState: function(newStateCtor){
            if (this.state) {
                if (this.state.ctor === newStateCtor) return;
                if (this.state.leaveState) this.state.leaveState.call(this);
            }

            // Must be re-entrant in case ctor changes state
            var prevState = this.state;
            var nextState = newStateCtor.call(this);
            if (this.state === prevState) {
                nextState.ctor = newStateCtor;
                this.state = nextState;
            }
        },

        findTargetNode: function(targetNode) {
            while(targetNode && targetNode.parentNode !== this.container) {
                targetNode = targetNode.parentNode;
            }
            return targetNode;
        },

        onContainerFocus: function(e) {
            e.stopPropagation();
            this.setChildNodesRoles();
        },

        setChildNodesRoles: function() {
            var nodes = this.container.childNodes;
            for(var i=0; i < nodes.length; i++) {
                if (nodes[i].nodeType != 1) continue;
                if (this.options.accessibility.items.role) {
                    nodes[i].setAttribute('role', this.options.accessibility.items.role);
                }
                if (false !== this.options.accessibility.items.tabIndex) {
                    nodes[i].tabIndex = this.options.accessibility.items.tabIndex;
                }
            }
        },

        unSetChildNodesRoles: function() {
            var nodes = this.container.childNodes;
            for(var i=0; i < nodes.length; i++) {
                if (nodes[i].nodeType != 1) continue;
                if (this.options.accessibility.items.role) {
                    nodes[i].removeAttribute('role');
                }
                if (false !== this.options.accessibility.items.tabIndex) {
                    nodes[i].removeAttribute('tabIndex');
                }
            }
        },
        onSelection: function(e) {
            e.stopPropagation();
            var isRelated = e.target === document || this.findTargetNode(e);
            var iOS = /(iPhone|iPad|iPod)/i.test(navigator.userAgent) && !/(Android|Windows)/i.test(navigator.userAgent);
            if (!isRelated) return;

            if (iOS) {
                // iOS doesn't allow selection to be prevented
                this.setState(this.states.idle);
            } else {
                if (!this.state.allowTextSelection) {
                    e.preventDefault();
                }
            }
        },

        addMouseHandlers: function() {
            // unlike touch events, mousemove/up is not conveniently fired on the same element,
            // but I don't need to listen to unrelated events all the time
            if (!this.mouseHandlersAttached) {
                this.mouseHandlersAttached = true;
                document.documentElement.addEventListener('mouseleave', this.onMouseLeave, false);
                window.addEventListener('mousemove', this.onMouseMove, true);
                window.addEventListener('mouseup', this.onMouseUp, true);
                window.addEventListener('blur', this.cancel, false);
            }
        },

        removeMouseHandlers: function() {
            if (this.mouseHandlersAttached) {
                this.mouseHandlersAttached = false;
                document.documentElement.removeEventListener('mouseleave', this.onMouseLeave, false);
                window.removeEventListener('mousemove', this.onMouseMove, true);
                window.removeEventListener('mouseup', this.onMouseUp, true);
                window.removeEventListener('blur', this.cancel, false);
            }
        },

        onMouseLeave: function(e) {
            e.stopPropagation();
            if (this.usingTouch) return;

            if (e.target === document.documentElement || e.relatedTarget === document.documentElement) {
                if (this.state.onLeave) {
                    this.state.onLeave.call(this);
                }
            }
        },

        onMouseDown: function(e) {
            e.stopPropagation();
            if (this.usingTouch || e.button != 0 || !this.setTarget(e)) return;

            this.addMouseHandlers(); // mouseup, etc.

            this.canPreventScrolling = true; // or rather it doesn't apply to mouse

            this.startAtPosition({
                x: e.clientX,
                y: e.clientY,
                time: e.timeStamp,
            });
        },

        onTouchStart: function(e) {
            e.stopPropagation();
            this.usingTouch = true;
            this.canPreventScrolling = true;

            // This implementation cares only about single touch
            if (e.touches.length > 1) {
                this.setState(this.states.idle);
                return;
            }

            if (!this.setTarget(e)) return;

            this.startAtPosition({
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
                time: e.timeStamp,
            });
        },

        setTarget: function(e) {
            var targetNode = this.findTargetNode(e.target);
            if (!targetNode) {
                this.setState(this.states.idle);
                return false;
            }

            // scrollContainer may be explicitly set via options, otherwise search upwards for a parent with an overflow-y property
            // fallback to document.scrollingElement (or documentElement on IE), and do not use document.body
            var scrollContainer = this.options.scrollContainer;
            if (!scrollContainer) {
                var top = document.scrollingElement || document.documentElement;
                scrollContainer = targetNode.parentNode;
                while (scrollContainer) {
                    if (scrollContainer == top) break;
                    if (scrollContainer != document.body && scrollContainer.scrollHeight > scrollContainer.clientHeight && window.getComputedStyle(scrollContainer)['overflow-y'] != 'visible') break;
                    scrollContainer = scrollContainer.parentNode;
                }
                scrollContainer = scrollContainer || top;
            }

            this.target = {
                originalTarget: e.target,
                node: targetNode,
                scrollContainer: scrollContainer,
                origScrollTop: scrollContainer.scrollTop,
                origScrollHeight: scrollContainer.scrollHeight,
                baseTransform: getTransform(targetNode),
            };
            return true;
        },

        startAtPosition: function(pos) {
            this.startPosition = this.previousPosition = this.latestPosition = pos;
            this.setState(this.states.undecided);
        },

        updatePosition: function(e, pos) {
            if (this.target == null) {
                return;
            }
            this.latestPosition = pos;

            if (this.state.onMove) {
                if (this.state.onMove.call(this) === false) {
                    e.preventDefault();
                }
            }

            // sample latestPosition 100ms for velocity
            if (this.latestPosition.time - this.previousPosition.time > 100) {
                this.previousPosition = this.latestPosition;
            }
        },

        onMouseMove: function(e) {
            e.stopPropagation();
            this.updatePosition(e, {
                x: e.clientX,
                y: e.clientY,
                time: e.timeStamp,
            });
        },

        onTouchMove: function(e) {
            e.stopPropagation();
            this.updatePosition(e, {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
                time: e.timeStamp,
            });

            // In Apple's touch model only the first move event after touchstart can prevent scrolling (and event.cancelable is broken)
            this.canPreventScrolling = false;
        },

        onMouseUp: function(e) {
            e.stopPropagation();
            if (this.usingTouch || e.button !== 0) return;

            if (this.state.onEnd && false === this.state.onEnd.call(this)) {
                e.preventDefault();
            }
        },

        onTouchEnd: function(e) {
            e.stopPropagation();
            if (e.touches.length > 1) {
                this.cancel();
            } else if (this.state.onEnd && false === this.state.onEnd.call(this)) {
                e.preventDefault();
            }
        },

        getTotalMovement: function() {
            var scrollOffset = this.target.scrollContainer.scrollTop - this.target.origScrollTop;
            return {
                x: this.latestPosition.x - this.startPosition.x,
                y: this.latestPosition.y - this.startPosition.y + scrollOffset,
                time: this.latestPosition.time - this.startPosition.time,
            };
        },

        getAbsoluteMovement: function() {
            var move = this.getTotalMovement();
            return {
                x: Math.abs(move.x),
                y: Math.abs(move.y),
                time: move.time,
                directionX: move.x < 0 ? 'left' : 'right',
                directionY: move.y < 0 ? 'up' : 'down',
            };
        },

        updateScrolling: function() {
            var triggerOffset = 40,
                offset = 0;

            var scrollable = this.target.scrollContainer,
                containerRect = scrollable.getBoundingClientRect(),
                targetRect = this.target.node.getBoundingClientRect(),
                bottomOffset = Math.min(containerRect.bottom, window.innerHeight) - targetRect.bottom,
                topOffset = targetRect.top - Math.max(containerRect.top, 0),
                maxScrollTop = this.target.origScrollHeight - Math.min(scrollable.clientHeight, window.innerHeight);

            if (bottomOffset < triggerOffset) {
              offset = Math.min(triggerOffset, triggerOffset - bottomOffset);
            }
            else if (topOffset < triggerOffset) {
              offset = Math.max(-triggerOffset, topOffset - triggerOffset);
            }

            scrollable.scrollTop = Math.max(0, Math.min(maxScrollTop, scrollable.scrollTop + offset));
        },

        dispatch: function(targetNode, eventName, detail) {
            var event = document.createEvent('CustomEvent');
            if (event && event.initCustomEvent) {
                event.initCustomEvent('slip:' + eventName, true, true, detail);
            } else {
                event = document.createEvent('Event');
                event.initEvent('slip:' + eventName, true, true);
                event.detail = detail;
            }
            return targetNode.dispatchEvent(event);
        },

        animateToZero: function(callback, target) {
            // save, because this.target/container could change during animation
            target = target || this.target;

            target.node.style[transitionJSPropertyName] = transformCSSPropertyName + ' 0.1s ease-out';
            target.node.style[transformJSPropertyName] = 'translate(0,0) ' + hwLayerMagicStyle + target.baseTransform.value;
            setTimeout(function(){
                target.node.style[transitionJSPropertyName] = '';
                target.node.style[transformJSPropertyName] = target.baseTransform.original;
                if (callback) callback.call(this, target);
            }.bind(this), 101);
        },


    };

    // AMD
    if ('function' === typeof define && define.amd) {
        define(function(){
            return Slip;
        });
    }
    // CJS
    if ('object' === typeof module && module.exports) {
        module.exports = Slip;
    }
    return Slip;

})();

    function setupSlip(list) {
        list.addEventListener('slip:beforeswipe', function(e){
            if (e.target.nodeName == 'INPUT' || e.target.classList.contains('demo-no-swipe')) {
                e.preventDefault();
            }
        }, false);
        list.addEventListener('slip:beforewait', function(e){
            if (e.target.classList.contains('instant')) e.preventDefault();
        }, false);
        list.addEventListener('slip:reorder', function(e){
            e.target.parentNode.insertBefore(e.target, e.detail.insertBefore);
            return false;
        }, false);
        return new Slip(list);
    }
    
function polar(data) {
//console.log(data);
d3.selectAll("#chart > *").remove(); 
        var formatIncome = d3.format(""),
            formatHsGrad = d3.format(""),
            formatHsGradAxis = d3.format("");
            

var width = 800,
    height = 800,
    jako = 400,
    radius = Math.min(width, height) / 2 - 30; // radius of the whole chart

    var r = d3.scaleLinear()
      .domain([0, 1])
      .range([0, radius]);

    var svg = d3.select("#chart").append('svg')
      //.call(zoom)
      .attr('width', width)
      .attr('height', height)
      

/*
.append('svg:image')
    .attr('xlink:href', 'taustakuva.svg')
    .attr("width", 800)
    .attr("height", 800)
    .attr("x", 0)
    .attr("y", 0)
*/    
    
      .append('g')
      .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');


svg.style.backgroundColor = "transparent";

/*
const imageUrl = "tvtaustakuva.svg";
    d3.xml(imageUrl)
      .then(response => {
        // Lisää taustakuva SVG:hen
        const image = d3.select(response.documentElement);
        svg.node().appendChild(image.node());
      });

*/





    var gr = svg.append('g')
      .attr('class', 'r axis')
      .selectAll('g')
      .data(r.ticks(5).slice(1))
      .enter().append('g');

    gr.append('circle')
      .attr('r', r);

    var ga = svg.append('g')
      .attr('class', 'a axis')
      .selectAll('g')
      .data(d3.range(0, 360, 30)) // line density
      .enter().append('g')
      .attr('transform', function(d) {
        return 'rotate(' + -d + ')';
      });

    ga.append('line')
      .attr('x2', radius);
            


    //var color = d3.scale.category20();
    //var color = d3.scaleOrdinal( d3.schemeCategory20 )
    var color = d3.scaleOrdinal(d3.schemeAccent);
    //var color = d3.scaleSequential(d3.interpolatePiYG);
    //var color = d3.scaleSequential(d3.interpolateYlOrRd);
    

    var line = d3.lineRadial()
      .radius(function(d) {
        return r(d[1]);
      })
      .angle(function(d) {
        return -d[0] + Math.PI / 2;
      });
  
//circles
var tooltip = d3.select("body")
	.append("div")
	.style("position", "absolute")
	.style("z-index", "10")
	.style("visibility", "hidden")
	.text("a simple tooltip");

svg.selectAll('point')
  .data(data)
  .enter()
  .append('circle')
  .attr('class', 'point')
  .attr('transform', function(d) {
  //console.log(d);
    var coors = line([d]).slice(1).slice(0, -1); 
    //console.log(coors);
    return 'translate(' + coors + ')'
  })
  .attr('r', function(d) {
    return d[2];
  })
  .attr('fill',function(d,i){
    return color(i);
  })
  .on("click", function(d){
    //console.log(d);
    //return tooltip.style("visibility", "visible");
  });







//labels
svg.selectAll('point')
  .data(data)
  .enter().append("text")
  .attr('transform', function(d) {var coors = line([d]).slice(1).slice(0, -1); 
    return 'translate(' + coors + ')'
  })
  .text(function(d) {         
        return d[3]; 
      });


// brushing and linking
var brush = d3.brush().extent([[0-jako, 0-jako], [width-jako, height-jako]]);
var brushArea = svg.append('g').attr('class', 'brush');

brush
  .on('start brush', brushed)
  .on('end', brushEnded);

brushArea.call(brush);

function brushed() {
  var selectedPoints = [];
  if (d3.event.selection !== null) {
    var brushSelection = d3.event.selection;
    svg.selectAll('circle.point').classed('selected', function(d) {
      var coors = line([d]).slice(1).slice(0, -1).split(',');
      var x = parseInt(coors[0], 10);
      var y = parseInt(coors[1], 10);
      var isSelected = x >= brushSelection[0][0] &&
          x <= brushSelection[1][0] &&
          y >= brushSelection[0][1] &&
          y <= brushSelection[1][1];
      if (isSelected && !selectedPoints.includes(d)) {
        selectedPoints.push(d);
      }
      return isSelected;
    });
  }
  updateLinkedCharts(selectedPoints);
}

function brushEnded() {
  if (d3.event.selection === null) {
    svg.selectAll('circle.point').classed('selected', false);
    updateLinkedCharts([]);
  }
}

function updateLinkedCharts(selectedPoints) {
  // update the linked chart(s) here with the selected points
//console.log('Selected points:', selectedPoints);
//console.log(selectedPoints);
//console.log(data);

/*
var tablet = '<div class="table"><div class="row header"><div class="cell">'
tablet += 'Paikka</div><div class="cell">Taso</div><div class="cell">Koko</div></div>'
    
    for(i=0;i < selectedPoints.length;i++){
tablet += '<div class="row">'
tablet += '<div class="cell" data-title="Paikka">' + selectedPoints[i][0] + '</div>'
tablet += '<div class="cell" data-title="Taso">' + selectedPoints[i][1] + '</div>'
tablet += '<div class="cell" data-title="Koko">' + selectedPoints[i][2] + '</div>'
tablet += '</div>'
}
tablet += '</div>'
document.getElementById('stable').innerHTML=tablet;                                
//console.log(tablet);                                
*/
}

function isBrushed(brush_coords, cx, cy) {
             var x0 = brush_coords[0][0],
                 x1 = brush_coords[1][0],
                 y0 = brush_coords[0][1],
                 y1 = brush_coords[1][1];
            return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;
        }
}

  function tarppi() {
var tiedosto = '<div xmlns="http://www.w3.org/1999/xhtml" id="svgs" class="hero-image"><svg xmlns="http://www.w3.org/2000/svg" width="800" height="800"><defs xmlns="http://www.w3.org/1999/xhtml"><style type="text/css">'

tiedosto += '<![CDATA[.hero-image { background-image: url("tvtaustakuva.svg"); background-color: rgb(255, 255, 255); height: 800px; width: 800px; background-position: center; background-repeat: no-repeat; background-size: cover; position: relative; opacity: 0.5; }.point { mix-blend-mode: multiply; }.axis line { fill: none; stroke: rgb(235, 235, 235); }.axis circle { fill: none; stroke: rgb(170, 170, 170); }.axis:last-of-type circle { stroke: rgb(51, 51, 51); }.line { fill: none; stroke: orange; stroke-width: 3px; }svg text { text-anchor: middle; font-size: 16px; font-family: Helvetica; }]]></style></defs>'

  
var svgElements = document.getElementById('chart');
tiedosto += svgElements.innerHTML;

var gElement = svgElements.querySelector('g');
//tiedosto += gElement.innerHTML;

tiedosto += '</svg></div>'
//console.log(tiedosto);  


/*

  //const svg = document.querySelector('svg');
  const base64doc = btoa(unescape(encodeURIComponent(tiedosto)));
  const a = document.createElement('a');
  const e = new MouseEvent('click');
  a.download = 'download.svg';
  a.href = 'data:image/svg+xml;base64,' + base64doc;
  a.dispatchEvent(e);
  
*/
  
  //const canvas = document.createElement("canvas");
  //const svg = document.querySelector('svg');
  const base64doc = btoa(unescape(encodeURIComponent(tiedosto)));
  //const w = parseInt(svg.getAttribute('width'));
  //const h = parseInt(svg.getAttribute('height'));
  const img_to_download = document.createElement('img');
  img_to_download.src = 'data:image/svg+xml;base64,' + base64doc;
  //console.log(w, h);
  img_to_download.onload = function () {
    console.log('img loaded');
    canvas.setAttribute('width', 800);
    canvas.setAttribute('height', 800);
    const context = canvas.getContext("2d");
    //context.clearRect(0, 0, w, h);
    context.drawImage(img_to_download,0,0,800,800);
    const dataURL = canvas.toDataURL('image/png');
    //if (window.navigator.msSaveBlob) {
     // window.navigator.msSaveBlob(canvas.msToBlob(), "download.png");
    //  e.preventDefault();
    //} else {
      const a = document.createElement('a');
      const my_evt = new MouseEvent('click');
      a.download = 'download.png';
      a.href = dataURL;
      a.dispatchEvent(my_evt);
    //}
    //canvas.parentNode.removeChild(canvas);
  }  
  
  
  
  
  
  
}


</script>
</body>
</html>