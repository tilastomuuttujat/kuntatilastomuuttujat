<!DOCTYPE html>
<html lang="fi" >
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
    <link href="http://www.jqueryscript.net/css/jquerysctipttop.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-cloud/1.2.5/d3.layout.cloud.js"></script>

<style>
.tcontainer { 
	max-width: 960px; 
	height: 100%;
	margin: 0 auto; 
	padding: 20px;
}

.tabs {
	position: relative;
	display: flex;
	min-height: 800px;
	border-radius: 8px 8px 0 0;
	overflow: hidden;
}

.tabby-tab {
	flex: 1;
}

.tabby-tab label {
	display: block;
	box-sizing: border-box;
	/* tab content must clear this */
		height: 40px;
	
	padding: 10px;
	text-align: center;
	background: #97ded1;
	cursor: pointer;
	transition: background 0.5s ease;
	
}

.tabby-tab label:hover {
	background: #7bacab;
}

.tabby-content {
	position: absolute;
	
	left: 0; bottom: 0; right: 0;
	/* clear the tab labels */
		top: 40px; 
	
	padding: 20px;
	border-radius: 0 0 8px 8px;

	
	transition: 
		opacity 0.8s ease,
		transform 0.8s ease		;
	
	/* show/hide */
		opacity: 0;
		transform: scale(0.1);
		transform-origin: top left;
	
}

.tabby-content img {
	float: left;
	margin-right: 20px;
	border-radius: 8px;
}


/* MAKE IT WORK ----- */

.tabby-tab [type=radio] { display: none; }
[type=radio]:checked ~ label {
	background: #7bacab;
	z-index: 2;
}

[type=radio]:checked ~ label ~ .tabby-content {
	z-index: 1;
	
	/* show/hide */
		opacity: 1;
		transform: scale(1);
}

/* BREAKPOINTS ----- */
@media screen and (max-width: 767px) {
	.tabs { min-height: 400px;}
}

@media screen and (max-width: 480px) {
	.tabs { min-height: 580px; }
	.tabby-tab label { 
		height: 60px;
	}
	.tabby-content { top: 60px; }
	.tabby-content img {
		float: none;
		margin-right: 0;
		margin-bottom: 20px;
	}
}
.slip-reordering {
    box-shadow: 0 2px 10px rgba(0,0,0,0.45);
}

.slip-swiping-container {
    overflow-x: hidden;
}

.slippylist li {
    user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    cursor: default;
}

/* the rest is junk for the demo page */
.slippylist li.demo-allow-select {
    padding: 1em;
    line-height: 1.3;
    user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
}
.slippylist li.demo-allow-select span {
    cursor: text;
}

.slippylist {
    max-width: 15em;
    clear:left;
    margin: 1em;
    padding: 0 0 1px;
}

.slippylist li {
    display: block;
    position: relative;
    border: 1px solid black;
    background: white;
    margin: 0; padding: 0 1em;
    border-radius: 3px;
    margin-bottom: -1px;
    max-width: 100%;
    line-height: 1.5;
    vertical-align: middle;
}

.slippylist input {
    vertical-align: middle;
}

.slippylist .instant::before {
    /*content: " ↑ ↓ ";*/
    content: "[";
    color: white;
}
.slippylist .instant {
    float: left;
}
.slippylist li::after {
    content: "[";
    color: white;
}

.skewed {
    transform: rotate(2deg) scale(0.99);
    -webkit-transform: rotate(2deg) scale(0.99);
}

.demo-no-swipe.demo-no-reorder {
    opacity: 0.5;

}

#scroll {
    overflow-y: scroll;
    max-height: 300px;
}

h1, h2, h3 {
    color: #666;
}
h1 {
    float:left;
    margin-top: 0;
    margin-right: 1ex;
}
h3 {
    margin-bottom: 0.2em;
    margin-top: 2em;
}
h1+p {
    overflow:auto;
    margin-top: 0.2em;
}

.button {
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
}

.container {
  position: relative;
  top: 50%;
  left: 50%;
  width: 320px;
  height: 400px;
  opacity: 0;
  visibility: hidden;
  transform: translate(-50%, -50%); 
}

.list-item {
  position: absolute;
  top: 0;
  left: 0;
  height: 30px;
  width: 100%;
}

.item-content {
  height: 100%;
  border: 0px solid rgba(123, 123, 123, 0.498039);
  border-radius: 4px;
  color: #999999;
  line-height: 30px;
  padding-left: 32px;
  font-size: 24px;
  font-weight: 400;
  background-color: white;
  box-shadow: rgba(0, 0, 0, 0.2) 0px 1px 2px 0px;
}

html,
body {
  width: 100vw;
  height: 100vh;
  margin: 0;
  border: 0;
  padding: 0;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

*,
*::before,
*::after {
  -webkit-box-sizing: inherit;
  -moz-box-sizing: inherit;
  box-sizing: inherit;
  box-sizing: border-box; 
}

.slider {
  padding: 3rem 0;
}
.slider > ul.slider-items {
  --_spacer: 1rem;
  display: grid;
  gap: var(--_spacer);
  grid-auto-flow: column;
  grid-auto-columns: 80vw;
  padding: 0 var(--_spacer) var(--_spacer);
  overflow-x: auto;
  overscroll-behavior-inline: contain;
  -ms-scroll-snap-type: inline mandatory;
      scroll-snap-type: inline mandatory;
  scroll-padding-inline: var(--_spacer, 1rem);

}
.slider > ul.slider-items::-webkit-scrollbar {
  height: 8px;
  border-radius: 8px;
}
.slider > ul.slider-items::-webkit-scrollbar-track {
  background: rgba(29, 55, 104, 0.15);
  border-radius: 8px;
}
.slider > ul.slider-items::-webkit-scrollbar-thumb {
  background: rgba(29, 55, 104, 0.75);
  border-radius: 8px;
}
.slider > ul.slider-items::-webkit-scrollbar-thumb:hover {
  background: #1d3768;
}
.slider > ul.slider-items > li {
  display: flex;
  scroll-snap-align: center;
  background: #e4e4e4;
  flex-direction: column;
  gap: 5px;
  padding: 1.5rem;
  font-family: Arial, sans-serif;
  color: #1D3768;
}
.slider > ul.slider-items > li > * {
  margin: 0;
}
.slider > ul.slider-items > li h3 {
  font-size: 24px;
  font-weight: bold;
}
.slider > ul.slider-dots {
  margin: 0;
  margin-top: 2rem;
  padding: 0;
  list-style: none;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}
.slider > ul.slider-dots > li {
  width: 8px;
  height: 8px;
  background: #1D3768;
  border-radius: 100%;
  opacity: 0.5;
  transition: opacity 0.2s ease-in-out;
}
.slider > ul.slider-dots > li.active {
  opacity: 1;
}
#demo1 {
  left: 100px;
}
#demo2 {
  left: 400px;
}

</style>

</head>
<body>
<div class="slider">
	<ul class="slider-items">
		<li data-id="0">
		
<img src="elonkeha_0.png">
		</li>
		<li data-id="1">
        <svg id="wordcloud1"></svg>   
		</li>
		<li data-id="2">
        <svg id="wordcloud2"></svg>
		</li>
		<li data-id="3">
        <svg id="wordcloud3"></svg>
		</li>
		<li data-id="4">
        <svg id="wordcloud4"></svg>
		</li>
	</ul>
	<ul class="slider-dots">
		<li class="active"></li>
		<li></li>
		<li></li>
		<li></li>
		<li></li>	
	</ul>
</div>
<div class="tcontainer">
	

	<div class="tabs">
		<div onClick="vihreat()" class="tabby-tab">
			<input type="radio" id="tab-1" name="tabby-tabs" checked>
			<label for="tab-1">Järjestä</label>
			<div class="tabby-content">
<table>
<td>Lähtökohdat
<ol id="demo1" class="slippylist"></ol>
</td>
<td>	Olosuhteet
<ol id="demo2" class="slippylist"></ol>
</td>
<td>Voimavarat
<ol id="demo3" class="slippylist"></ol>
</td>
<td>	Ympäristö
<ol id="demo4" class="slippylist"></ol>
</td>
</table>
			</div>
		</div>

		<div class="tabby-tab">
			<input type="radio" id="tab-2" name="tabby-tabs">
			<label for="tab-2">Itsetuntemus</label>
			<div class="tabby-content">
<svg id="radar"></svg>
        <div id="my-tree">
        <section class="container"></section> 
        </div>
			</div>
		</div>

		<div class="tabby-tab">
			<input type="radio" id="tab-3" name="tabby-tabs">
			<label for="tab-3">Työvalmennus</label>
			<div class="tabby-content">

			</div>
		</div>

		<div class="tabby-tab">
			<input type="radio" id="tab-4" name="tabby-tabs">
			<label for="tab-4">Osallisuusvalmennus</label>
			<div class="tabby-content">

			</div>
		</div>
	</div>


<script>

const lista1 = [{"group":"1","text":"Ahkeruus","size":"20","choice":"0"},{"group":"1","text":"Avoimmuus","size":"20","choice":"0"},{"group":"1","text":"Ekologisuus","size":"20","choice":"0"},{"group":"1","text":"Eläinoikeudet","size":"20","choice":"0"},{"group":"1","text":"Empaattisuus","size":"20","choice":"0"},{"group":"1","text":"Esteettisyys","size":"20","choice":"0"},{"group":"1","text":"Hengellisyys","size":"20","choice":"0"},{"group":"1","text":"Henkisyys","size":"10","choice":"0"},{"group":"1","text":"Hillitty","size":"10","choice":"0"},{"group":"1","text":"Huumori","size":"10","choice":"0"},{"group":"1","text":"Huumorintaju","size":"10","choice":"0"},{"group":"1","text":"Iloisuus","size":"10","choice":"0"},{"group":"1","text":"Innovatiivisuus","size":"10","choice":"0"},{"group":"1","text":"Itsehillintä","size":"10","choice":"0"},{"group":"1","text":"Itsekontrolli","size":"10","choice":"0"},{"group":"1","text":"Itsekritiikki","size":"10","choice":"0"},{"group":"1","text":"Itsereflektio","size":"10","choice":"0"},{"group":"1","text":"Itsetutkiskelu","size":"10","choice":"0"},{"group":"1","text":"Joustavuus","size":"10","choice":"0"},{"group":"1","text":"Kärsivällisyys","size":"10","choice":"0"},{"group":"1","text":"Kauneus","size":"10","choice":"0"},{"group":"1","text":"Käytännöllisyys","size":"10","choice":"0"},{"group":"1","text":"Kiireettömyys","size":"10","choice":"0"},{"group":"1","text":"Kiitollisuus","size":"10","choice":"0"},{"group":"1","text":"Kiltteys","size":"5","choice":"0"},{"group":"1","text":"Lämminhenkisyys","size":"5","choice":"0"},{"group":"1","text":"Luonnonläheisyys","size":"5","choice":"0"},{"group":"1","text":"Mielihyvä","size":"5","choice":"0"},{"group":"1","text":"Mielikuvitus","size":"5","choice":"0"},{"group":"1","text":"Minäkuva","size":"5","choice":"0"},{"group":"1","text":"Myönteisyys","size":"5","choice":"0"},{"group":"1","text":"Nauru","size":"5","choice":"0"},{"group":"1","text":"Nöyryys","size":"5","choice":"0"},{"group":"1","text":"Omistautuminen","size":"5","choice":"0"},{"group":"1","text":"Onnellisuus","size":"5","choice":"0"},{"group":"1","text":"Optimistisuus","size":"5","choice":"0"},{"group":"1","text":"Pohdiskelevuus","size":"5","choice":"0"},{"group":"1","text":"Positiivisuus","size":"5","choice":"0"},{"group":"1","text":"Puolueettomuus","size":"5","choice":"0"},{"group":"1","text":"Rakastavuus","size":"5","choice":"0"},{"group":"1","text":"Rakentavuus","size":"5","choice":"0"},{"group":"1","text":"Rakkaus","size":"5","choice":"0"},{"group":"1","text":"Rauhallisuus","size":"5","choice":"0"},{"group":"1","text":"Realistisuus","size":"5","choice":"0"},{"group":"1","text":"Rehellisyys","size":"5","choice":"0"},{"group":"1","text":"Rentoutuneisuus","size":"5","choice":"0"}];

const lista2 = [{"group":"1","text":"Säännöllisyys","size":"20","choice":"0"},{"group":"1","text":"Säästäminen","size":"2","choice":"0"},{"group":"1","text":"Sitkeys","size":"2","choice":"0"},{"group":"1","text":"Sitoutuminen","size":"20","choice":"0"},{"group":"1","text":"Tarkkuus","size":"2","choice":"0"},{"group":"1","text":"Tasapainoisuus","size":"2","choice":"0"},{"group":"10","text":"Täsmällisyys","size":"2","choice":"0"},{"group":"1","text":"Tavoitteellisuus","size":"2","choice":"0"},{"group":"1","text":"Terävyys","size":"2","choice":"0"},{"group":"1","text":"Tiedonjano","size":"2","choice":"0"},{"group":"1","text":"Toiveikkuus","size":"2","choice":"0"},{"group":"1","text":"Tunteellisuus","size":"15","choice":"0"},{"group":"1","text":"Tutkiskelu","size":"2","choice":"0"},{"group":"1","text":"Tyyneys","size":"20","choice":"0"},{"group":"1","text":"Tyytyväisyys","size":"2","choice":"0"},{"group":"1","text":"Uteliaisuus","size":"2","choice":"0"},{"group":"1","text":"Uudistuminen","size":"2","choice":"0"},{"group":"1","text":"Vaatimattomuus","size":"2","choice":"0"},{"group":"10","text":"Vakaus","size":"2","choice":"0"},{"group":"1","text":"Valppaus","size":"2","choice":"0"},{"group":"1","text":"Vapaus","size":"2","choice":"0"},{"group":"1","text":"Vapautuneisuus","size":"2","choice":"0"},{"group":"1","text":"Varovaisuus","size":"15","choice":"0"},{"group":"1","text":"Vastuullisuus","size":"10","choice":"0"},{"group":"1","text":"Voimaantuminen","size":"1","choice":"0"},{"group":"1","text":"Yhdenvertaisuus","size":"1","choice":"0"},{"group":"10","text":"Yhteenkuuluvuus","size":"1","choice":"0"},{"group":"1","text":"Yksilöllisyys","size":"10","choice":"0"},{"group":"1","text":"Ymmärtävyys","size":"1","choice":"0"},{"group":"1","text":"Ympäristöystävällisyys","size":"1","choice":"0"},{"group":"1","text":"Ystävällisyys","size":"1","choice":"0"},{"group":"1","text":"Ytimekkyys","size":"1","choice":"0"}];

const lista3 = [{"group":"2","text":"Anteliaisuus","size":"15","choice":"0"},{"group":"2","text":"Arvostus","size":"15","choice":"0"},{"group":"2","text":"Auttaminen","size":"15","choice":"0"},{"group":"2","text":"Avuliaisuus","size":"15","choice":"0"},{"group":"2","text":"Huomaavaisuus","size":"15","choice":"0"},{"group":"2","text":"Hyväksyvyys","size":"15","choice":"0"},{"group":"2","text":"Ilahduttavuus","size":"15","choice":"0"},{"group":"2","text":"Kannustavuus","size":"15","choice":"0"},{"group":"2","text":"Kunnioittavuus","size":"5","choice":"0"},{"group":"2","text":"Myötätuntoisuus","size":"5","choice":"0"},{"group":"2","text":"Oikeudenmukaisuus","size":"5","choice":"0"},{"group":"2","text":"Solidaarisuus","size":"5","choice":"0"},{"group":"2","text":"Suojelevuus","size":"5","choice":"0"},{"group":"2","text":"Tasapuolisuus","size":"5","choice":"0"},{"group":"2","text":"Tunnustavuus","size":"5","choice":"0"},{"group":"3","text":"Ajanhallinta","size":"15","choice":"0"},{"group":"3","text":"Autonomia","size":"15","choice":"0"},{"group":"3","text":"Elämänmyönteisyys","size":"15","choice":"0"},{"group":"3","text":"Energisyys","size":"15","choice":"0"},{"group":"3","text":"Harkitsevuus","size":"10","choice":"0"},{"group":"3","text":"Hyvinvointi","size":"10","choice":"0"},{"group":"3","text":"Innokkuus","size":"10","choice":"0"},{"group":"3","text":"Innostus","size":"10","choice":"0"},{"group":"3","text":"Intohimoisuus","size":"10","choice":"0"},{"group":"3","text":"Intuitio","size":"10","choice":"0"},{"group":"3","text":"Itsearvostus","size":"10","choice":"0"},{"group":"3","text":"Itseluottamus","size":"10","choice":"0"},{"group":"3","text":"Itsenäisyys","size":"10","choice":"0"},{"group":"3","text":"Itsensätoteutus","size":"10","choice":"0"},{"group":"3","text":"Itsesuojelu","size":"10","choice":"0"},{"group":"3","text":"Itsetuntemus","size":"10","choice":"0"},{"group":"3","text":"Jaksaminen","size":"10","choice":"0"},{"group":"3","text":"Järjestelmällisyys","size":"10","choice":"0"}];
  
var lista4 = [{"group":"3","text":"Kasvuhakuisuus","size":"4","choice":"0"},{"group":"3","text":"Kasvuhaluisuus","size":"4","choice":"0"},{"group":"3","text":"Kehittyvyys","size":"4","choice":"0"},{"group":"3","text":"Keskittyminen","size":"4","choice":"0"},{"group":"3","text":"Kestävyys","size":"4","choice":"0"},{"group":"3","text":"Kiinnostus","size":"4","choice":"0"},{"group":"3","text":"Kilpailuhenkisyys","size":"4","choice":"0"},{"group":"3","text":"Kokeilunhalu","size":"4","choice":"0"},{"group":"3","text":"Kriittisyys","size":"4","choice":"0"},{"group":"3","text":"Kyvykkyys","size":"4","choice":"0"},{"group":"3","text":"Luotettavuus","size":"4","choice":"0"},{"group":"3","text":"Luottamus","size":"4","choice":"0"},{"group":"3","text":"Luottamuskyky","size":"4","choice":"0"},{"group":"3","text":"Merkityksellisyys","size":"4","choice":"0"},{"group":"3","text":"Mielekkyys","size":"4","choice":"0"},{"group":"3","text":"Mielenrauha","size":"4","choice":"0"},{"group":"3","text":"Muutoskyky","size":"4","choice":"0"},{"group":"3","text":"Objektiivisuus","size":"4","choice":"0"},{"group":"3","text":"Oppimishalu","size":"4","choice":"0"},{"group":"3","text":"Osaaminen","size":"4","choice":"0"},{"group":"3","text":"Päämäärät","size":"4","choice":"0"},{"group":"4","text":"Päätöksenteko","size":"15","choice":"0"},{"group":"4","text":"Päättäväisyys","size":"15","choice":"0"},{"group":"4","text":"Pelottomuus","size":"15","choice":"0"},{"group":"4","text":"Ratkaisukeskeisyys","size":"15","choice":"0"},{"group":"4","text":"Riskinottokyky","size":"10","choice":"0"},{"group":"4","text":"Rohkeus","size":"10","choice":"0"},{"group":"4","text":"Ruokahalu","size":"10","choice":"0"},{"group":"4","text":"Saavutukset","size":"10","choice":"0"},{"group":"4","text":"Selkeys","size":"10","choice":"0"},{"group":"4","text":"Selviytymiskyky","size":"10","choice":"0"},{"group":"4","text":"Sietokyky","size":"10","choice":"0"},{"group":"4","text":"Sisukkuus","size":"10","choice":"0"},{"group":"4","text":"Sopeutuminen","size":"10","choice":"0"},{"group":"4","text":"Tarkkailevuus","size":"10","choice":"0"},{"group":"4","text":"Tarkoitus","size":"4","choice":"0"},{"group":"4","text":"Tarmokkuus","size":"4","choice":"0"},{"group":"4","text":"Terveellisyys","size":"4","choice":"0"},{"group":"4","text":"Tilannetaju","size":"4","choice":"0"},{"group":"4","text":"Tunnistaminen","size":"4","choice":"0"},{"group":"4","text":"Vahvistuminen","size":"4","choice":"0"},{"group":"4","text":"Valinnanvapaus","size":"4","choice":"0"},{"group":"4","text":"Viihtyvyys","size":"4","choice":"0"},{"group":"4","text":"Vilkkaus","size":"4","choice":"0"},{"group":"4","text":"Yhteisöllisyys","size":"4","choice":"0"},{"group":"4","text":"Yhteistyö","size":"4","choice":"0"},{"group":"4","text":"Yhteistyöhalukkuus","size":"4","choice":"0"},{"group":"4","text":"Yritteliäisyys","size":"4","choice":"0"}];

var varinumero = 0;
var round = 0;
var laskuri = 0;
var clouds = ["#wordcloud1","#wordcloud2","#wordcloud3","#wordcloud4","#wordcloud5","#wordcloud6","#wordcloud7","#wordcloud8"];
var order = ["demo1","demo2","demo3","demo4"];
var listat = [lista1,lista2,lista3,lista4];
var valitut1 = [];
var valitut2 = [];
var valitut3 = [];
var valitut4 = [];


function pilvessa() {

var listaId = listat[laskuri]; 
var cloudId = clouds[laskuri];

const marginTop = 0, 
  marginRight = 0,
  marginBottom = 0,
  marginLeft = 0,
  width = 640,
  height = 400,
  maxWords = 250, 
  fontFamily = "sans-serif",
  fontScale = 15,
  padding = 0,
  rotate = 0;


    const leveys = 800;
    const korkeus = 400;

    const layout = d3.layout.cloud()
      .size([leveys, korkeus])
      .words(listaId)
      .padding(padding)
      .rotate(() => rotate)
      .font(fontFamily)
      .fontSize(d => Math.sqrt(d.size) * fontScale)
      .on("end", piirra);

    layout.start();

    function piirra(sanat) {
      //const svg = d3.select("#word-cloud")
      const svg = d3.select(cloudId)
        .attr("width", leveys)
        .attr("height", korkeus);

      const g = svg.append("g")
        .attr("transform", `translate(${leveys / 2}, ${korkeus / 2})`);

      const tekstit = g.selectAll("text")
        .data(sanat)
        .enter()
        .append("text")
        .style("font-size", d => `${d.size}px`)
        .style("font-family", "Arial")
        .attr("text-anchor", "middle")
        .attr("transform", d => `translate(${d.x}, ${d.y})rotate(${d.rotate})`)
        .text(d => d.text)
        .style("cursor", "pointer")
        .style("fill", "black")
        .each(function (d) {
          d.vari = 0; 
        })
        .on("click", function (d) {
          d.vari = (d.vari + 1) % 3; 
          d3.select(this).style("fill", getColor(d.vari));


if(cloudId === clouds[0]) {
round = 0;
let riviIndeksi = valitut1.findIndex(rivi => rivi.includes(d.text));
if (riviIndeksi !== -1) {
  valitut1[riviIndeksi][2] = d.vari;
  }else{
  valitut1.push([d.text,round,d.vari]);  
}
}

if(cloudId === clouds[1]) {
round = 1;
let riviIndeksi = valitut2.findIndex(rivi => rivi.includes(d.text));
if (riviIndeksi !== -1) {
  valitut2[riviIndeksi][2] = d.vari;
  }else{
  valitut2.push([d.text,round,d.vari]);  
}
}

if(cloudId === clouds[2]) {
round = 2;
let riviIndeksi = valitut3.findIndex(rivi => rivi.includes(d.text));
if (riviIndeksi !== -1) {
  valitut3[riviIndeksi][2] = d.vari;
  }else{
  valitut3.push([d.text,round,d.vari]);  
}
}

if(cloudId === clouds[3]) {
round = 3;
let riviIndeksi = valitut4.findIndex(rivi => rivi.includes(d.text));
if (riviIndeksi !== -1) {
  valitut4[riviIndeksi][2] = d.vari;
  }else{
  valitut4.push([d.text,round,d.vari]);  
}
}

vihreat();
          
});

function getColor(varinumero) {
        if (varinumero === 0) {
          return "black";
        } else if (varinumero === 1) {
          return "green";
        } else if (varinumero === 2) {
          return "red";
        }
      }
    }
    
}//pilvessa 


function vihreat(){

if(round===0) {
var table = '';
var montako = valitut1.length;
for (var r = 0; r < montako; r++) {
if(valitut1[r][2] === 1) table += '<li class="demo-no-swipe"><span class="instant" style="color:green;">' + valitut1[r][0] + ' ' + valitut1[r][2] + '</span></li>'
if(valitut1[r][2] === 2) table += '<li class="demo-no-swipe"><span class="instant" style="color:red;">' + valitut1[r][0] + ' ' + valitut1[r][2] + '</span></li>'
setupSlip(document.getElementById('demo1'));
}
}

if(round===1) {
var table = '';
var montako = valitut2.length;
for (var r = 0; r < montako; r++) {
if(valitut2[r][2] === 1) table += '<li class="demo-no-swipe"><span class="instant" style="color:green;">' + valitut2[r][0] + ' ' + valitut2[r][2] + '</span></li>'
if(valitut2[r][2] === 2) table += '<li class="demo-no-swipe"><span class="instant" style="color:red;">' + valitut2[r][0] + ' ' + valitut2[r][2] + '</span></li>'
setupSlip(document.getElementById('demo2'));
}
}

if(round===2) {
var table = '';
var montako = valitut3.length;
for (var r = 0; r < montako; r++) {
if(valitut3[r][2] === 1) table += '<li class="demo-no-swipe"><span class="instant" style="color:green;">' + valitut3[r][0] + ' ' + valitut3[r][2] + '</span></li>'
if(valitut3[r][2] === 2) table += '<li class="demo-no-swipe"><span class="instant" style="color:red;">' + valitut3[r][0] + ' ' + valitut3[r][2] + '</span></li>'
setupSlip(document.getElementById('demo3'));
}
}

if(round===3) {
var table = '';
var montako = valitut4.length;
for (var r = 0; r < montako; r++) {
if(valitut4[r][2] === 1) table += '<li class="demo-no-swipe"><span class="instant" style="color:green;">' + valitut4[r][0] + ' ' + valitut4[r][2] + '</span></li>'
if(valitut4[r][2] === 2) table += '<li class="demo-no-swipe"><span class="instant" style="color:red;">' + valitut4[r][0] + ' ' + valitut4[r][2] + '</span></li>'
setupSlip(document.getElementById('demo4'));
}
}

document.getElementById(order[round]).innerHTML = table;
}


function valmennus() {




}



const listElement = document.querySelector('.slider ul.list');
const intersectionObserverElements = document.querySelectorAll('.slider > ul.slider-items > li');
const dots = document.querySelectorAll('.slider > ul.slider-dots > li');

function setActiveDot(selectedIndex) {
	dots.forEach((dot, index) => {
		dot.classList.remove('active');
		if (index === selectedIndex) {
			dot.classList.add('active');
		}
	});
}

let options = {
	root: listElement,
	rootMargin: '0px',
	threshold: [1]
}

let callback = (entries, observer) => {
	entries.forEach(entry => {
		if (entry.intersectionRatio === 1) {
			let dataId = `${entry.target.getAttribute('data-id')}`;
			setActiveDot(parseInt(dataId));
		}
	});
};

let observer = new IntersectionObserver(callback, options);

intersectionObserverElements.forEach((card) => {
	observer.observe(card);
});


  pilvessa();
    laskuri +=1;
    pilvessa();
    laskuri +=1;
    pilvessa();
    laskuri +=1;
    pilvessa();
  
  
  var sohvi = {"svg_id":"radar","width":900,"height":700,"colors":{"background":"#fff","grid":"#dddde0","inactive":"#ddd"},"title":"Valmennuskehä","date":"2023.05","quadrants":[{"name":"Verkostoituminen"},{"name":"Vuorovaikutus"},{"name":"Itseluottamus"},{"name":"Ajanhallinta"}],"rings":[{"name":"VAHVUUDET","color":"#5ba300"},{"name":"ARVOT","color":"#009eb0"},{"name":"ASENTEET","color":"#c7ba00"},{"name":"HEIKKOUDET","color":"#e09b96"}],"print_layout":true,"links_in_new_tabs":true,"entries":[{"quadrant":3,"ring":2,"label":"Ahkeruus","active":true,"moved":0},{"quadrant":3,"ring":3,"label":"Avoimmuus","active":true,"moved":0},{"quadrant":3,"ring":0,"label":"Ekologisuus","active":true,"moved":0},{"quadrant":3,"ring":2,"label":"Eläinoikeudet","active":true,"moved":0},{"quadrant":3,"ring":0,"label":"Empaattisuus","active":true,"moved":0},{"quadrant":3,"ring":0,"label":"Esteettisyys","active":true,"moved":0},{"quadrant":3,"ring":2,"label":"Itsekritiikki","active":true,"moved":0},{"quadrant":2,"ring":0,"label":"Kauneus","active":true,"moved":0},{"quadrant":2,"ring":0,"label":"Kiltteys","active":true,"moved":0},{"quadrant":2,"ring":3,"label":"Myönteisyys","active":true,"moved":0},{"quadrant":2,"ring":2,"label":"Omistautuminen","active":true,"moved":0},{"quadrant":2,"ring":1,"label":"Rakastavuus","active":true,"moved":0},{"quadrant":2,"ring":1,"label":"Rehellisyys","active":true,"moved":1},{"quadrant":2,"ring":1,"label":"Tyytyväisyys","active":true,"moved":0},{"quadrant":2,"ring":1,"label":"Anteliaisuus","active":true,"moved":0},{"quadrant":2,"ring":3,"label":"Huomaavaisuus","active":true,"moved":0},{"quadrant":2,"ring":3,"label":"Myötätuntoisuus","active":true,"moved":0},{"quadrant":2,"ring":3,"label":"Autonomia","active":true,"moved":0},{"quadrant":2,"ring":3,"label":"Itsetuntemus","active":true,"moved":0},{"quadrant":2,"ring":3,"label":"Kasvuhaluisuus","active":true,"moved":0},{"quadrant":2,"ring":2,"label":"Päämäärät","active":true,"moved":0},{"quadrant":2,"ring":3,"label":"Rohkeus","active":true,"moved":0},{"quadrant":2,"ring":3,"label":"Sopeutuminen","active":true,"moved":0},{"quadrant":2,"ring":0,"label":"Tunnistaminen","active":true,"moved":0},{"quadrant":1,"ring":0,"label":"Viihtyvyys","active":true,"moved":0},{"quadrant":1,"ring":0,"label":"Yhteisöllisyys","active":true,"moved":0},{"quadrant":1,"ring":1,"label":"Yhteistyö","active":true,"moved":1},{"quadrant":1,"ring":1,"label":"Yritteliäisyys","active":true,"moved":0},{"quadrant":1,"ring":1,"label":"Saavutukset","active":true,"moved":0},{"quadrant":1,"ring":0,"label":"Selkeys","active":true,"moved":0},{"quadrant":1,"ring":0,"label":"Tarmokkuus","active":true,"moved":0},{"quadrant":1,"ring":0,"label":"Tilannetaju","active":true,"moved":0},{"quadrant":1,"ring":2,"label":"Hyväksyvyys","active":true,"moved":0},{"quadrant":1,"ring":2,"label":"Ilahduttavuus","active":true,"moved":0},{"quadrant":1,"ring":3,"label":"Kunnioittavuus","active":true,"moved":0},{"quadrant":0,"ring":1,"label":"Tunnustavuus","active":true,"moved":0},{"quadrant":0,"ring":2,"label":"Nauru","active":true,"moved":0}]};
  
  
rad();

function rad(){

radar_visualization();
  function radar_visualization(config) {
//console.log(config);
config = sohvi;
  // custom random number generator, to make random sequence reproducible
  // source: https://stackoverflow.com/questions/521295
  var seed = 32;
  function random() {
    var x = Math.sin(seed++) * 10000;
    return x - Math.floor(x);
  }

  function random_between(min, max) {
    return min + random() * (max - min);
  }

  function normal_between(min, max) {
    return min + (random() + random()) * 0.5 * (max - min);
  }

  // radial_min / radial_max are multiples of PI
  const quadrants = [
    { radial_min: 0, radial_max: 0.5, factor_x: 1, factor_y: 1 },
    { radial_min: 0.5, radial_max: 1, factor_x: -1, factor_y: 1 },
    { radial_min: -1, radial_max: -0.5, factor_x: -1, factor_y: -1 },
    { radial_min: -0.5, radial_max: 0, factor_x: 1, factor_y: -1 }
  ];

  const rings = [
    { radius: 80 },
    { radius: 130 },
    { radius: 180 },
    { radius: 230 }
  ];

  const title_offset =
    { x: -320, y: -380 };

  const footer_offset =
    { x: -320, y: 220 };

  const legend_offset = [
    { x: 180, y: -290 },
    { x: -400, y: 150 },
    { x: -400, y: -290 },
    { x: 180, y: 150 }
  ];

  function polar(cartesian) {
    var x = cartesian.x;
    var y = cartesian.y;
    return {
      t: Math.atan2(y, x),
      r: Math.sqrt(x * x + y * y)
    }
  }

  function cartesian(polar) {
    return {
      x: polar.r * Math.cos(polar.t),
      y: polar.r * Math.sin(polar.t)
    }
  }

  function bounded_interval(value, min, max) {
    var low = Math.min(min, max);
    var high = Math.max(min, max);
    return Math.min(Math.max(value, low), high);
  }

  function bounded_ring(polar, r_min, r_max) {
    return {
      t: polar.t,
      r: bounded_interval(polar.r, r_min, r_max)
    }
  }

  function bounded_box(point, min, max) {
    return {
      x: bounded_interval(point.x, min.x, max.x),
      y: bounded_interval(point.y, min.y, max.y)
    }
  }

  function segment(quadrant, ring) {
    var polar_min = {
      t: quadrants[quadrant].radial_min * Math.PI,
      r: ring === 0 ? 30 : rings[ring - 1].radius
    };
    var polar_max = {
      t: quadrants[quadrant].radial_max * Math.PI,
      r: rings[ring].radius
    };
    var cartesian_min = {
      x: 15 * quadrants[quadrant].factor_x,
      y: 15 * quadrants[quadrant].factor_y
    };
    var cartesian_max = {
      x: rings[3].radius * quadrants[quadrant].factor_x,
      y: rings[3].radius * quadrants[quadrant].factor_y
    };
    return {
      clipx: function(d) {
        var c = bounded_box(d, cartesian_min, cartesian_max);
        var p = bounded_ring(polar(c), polar_min.r + 15, polar_max.r - 15);
        d.x = cartesian(p).x; // adjust data too!
        return d.x;
      },
      clipy: function(d) {
        var c = bounded_box(d, cartesian_min, cartesian_max);
        var p = bounded_ring(polar(c), polar_min.r + 15, polar_max.r - 15);
        d.y = cartesian(p).y; // adjust data too!
        return d.y;
      },
      random: function() {
        return cartesian({
          t: random_between(polar_min.t, polar_max.t),
          r: normal_between(polar_min.r, polar_max.r)
        });
      }
    }
  }

  // position each entry randomly in its segment
  for (var i = 0; i < config.entries.length; i++) {
    var entry = config.entries[i];
    entry.segment = segment(entry.quadrant, entry.ring);
    var point = entry.segment.random();
    entry.x = point.x;
    entry.y = point.y;
    entry.color = entry.active || config.print_layout ?
      config.rings[entry.ring].color : config.colors.inactive;
  }

  // partition entries according to segments
  var segmented = new Array(4);
  for (var quadrant = 0; quadrant < 4; quadrant++) {
    segmented[quadrant] = new Array(4);
    for (var ring = 0; ring < 4; ring++) {
      segmented[quadrant][ring] = [];
    }
  }
  for (var i=0; i<config.entries.length; i++) {
    var entry = config.entries[i];
    segmented[entry.quadrant][entry.ring].push(entry);
  }

  // assign unique sequential id to each entry
  var id = 1;
  for (var quadrant of [2,3,1,0]) {
    for (var ring = 0; ring < 4; ring++) {
      var entries = segmented[quadrant][ring];
      entries.sort(function(a,b) { return a.label.localeCompare(b.label); })
      for (var i=0; i<entries.length; i++) {
        entries[i].id = "" + id++;
      }
    }
  }

  function translate(x, y) {
    return "translate(" + x + "," + y + ")";
  }

  function viewbox(quadrant) {
    return [
      Math.max(0, quadrants[quadrant].factor_x * 400) - 420,
      Math.max(0, quadrants[quadrant].factor_y * 400) - 420,
      440,
      440
    ].join(" ");
  }

  var svg = d3.select("svg#" + config.svg_id)
    .style("background-color", config.colors.background)
    .attr("width", config.width)
    .attr("height", config.height);

  var radar = svg.append("g");
  if ("zoomed_quadrant" in config) {
    svg.attr("viewBox", viewbox(config.zoomed_quadrant));
  } else {
    radar.attr("transform", translate(config.width / 2, config.height / 2));
  }

  var grid = radar.append("g");

  // draw grid lines
  grid.append("line")
    .attr("x1", 0).attr("y1", -400)
    .attr("x2", 0).attr("y2", 400)
    .style("stroke", config.colors.grid)
    .style("stroke-width", 1);
  grid.append("line")
    .attr("x1", -400).attr("y1", 0)
    .attr("x2", 400).attr("y2", 0)
    .style("stroke", config.colors.grid)
    .style("stroke-width", 1);

  // background color. Usage `.attr("filter", "url(#solid)")`
  // SOURCE: https://stackoverflow.com/a/31013492/2609980
  var defs = grid.append("defs");
  var filter = defs.append("filter")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", 1)
    .attr("height", 1)
    .attr("id", "solid");
  filter.append("feFlood")
    .attr("flood-color", "rgb(0, 0, 0, 0.8)");
  filter.append("feComposite")
    .attr("in", "SourceGraphic");

  // draw rings
  for (var i = 0; i < rings.length; i++) {
    grid.append("circle")
      .attr("cx", 0)
      .attr("cy", 0)
      .attr("r", rings[i].radius)
      .style("fill", "none")
      .style("stroke", config.colors.grid)
      .style("stroke-width", 1);
    if (config.print_layout) {
      grid.append("text")
        .text(config.rings[i].name)
        .attr("y", -rings[i].radius + 62)
        .attr("text-anchor", "middle")
        .style("fill", config.rings[i].color)
        .style("opacity", 0.35)
        .style("font-family", "Arial, Helvetica")
        .style("font-size", "42px")
        .style("font-weight", "bold")
        .style("pointer-events", "none")
        .style("user-select", "none");
    }
  }

  function legend_transform(quadrant, ring, index=null) {
    var dx = ring < 2 ? 0 : 140;
    var dy = (index == null ? -16 : index * 12);
    if (ring % 2 === 1) {
      dy = dy + 36 + segmented[quadrant][ring-1].length * 12;
    }
    return translate(
      legend_offset[quadrant].x + dx,
      legend_offset[quadrant].y + dy
    );
  }

  // draw title and legend (only in print layout)
  if (config.print_layout) {

    // title
    radar.append("text")
      .attr("transform", translate(title_offset.x, title_offset.y))
      .text(config.title)
      .style("font-family", "Arial, Helvetica")
      .style("font-size", "30")
      .style("font-weight", "bold")

    // date
    radar
      .append("text")
      .attr("transform", translate(title_offset.x, title_offset.y + 20))
      .text(config.date || "")
      .style("font-family", "Arial, Helvetica")
      .style("font-size", "14")
      .style("fill", "#999")
/*
    // footer
    radar.append("text")
      .attr("transform", translate(footer_offset.x, footer_offset.y))
      .text("▲ moved up     ▼ moved down")
      .attr("xml:space", "preserve")
      .style("font-family", "Arial, Helvetica")
      .style("font-size", "10px");
*/
    // legend
    var legend = radar.append("g");
    for (var quadrant = 0; quadrant < 4; quadrant++) {
      legend.append("text")
        .attr("transform", translate(
          legend_offset[quadrant].x,
          legend_offset[quadrant].y - 45
        ))
        .text(config.quadrants[quadrant].name)
        .style("font-family", "Arial, Helvetica")
        .style("font-size", "18px")
        .style("font-weight", "bold");
      for (var ring = 0; ring < 4; ring++) {
        legend.append("text")
          .attr("transform", legend_transform(quadrant, ring))
          .text(config.rings[ring].name)
          .style("font-family", "Arial, Helvetica")
          .style("font-size", "12px")
          .style("font-weight", "bold")
          .style("fill", config.rings[ring].color);
        legend.selectAll(".legend" + quadrant + ring)
          .data(segmented[quadrant][ring])
          .enter()
            .append("a")
              .attr("href", function (d, i) {
                 return d.link ? d.link : "#"; // stay on same page if no link was provided
              })
              // Add a target if (and only if) there is a link and we want new tabs
              .attr("target", function (d, i) {
                 return (d.link && config.links_in_new_tabs) ? "_blank" : null;
              })
            .append("text")
              .attr("transform", function(d, i) { return legend_transform(quadrant, ring, i); })
              .attr("class", "legend" + quadrant + ring)
              .attr("id", function(d, i) { return "legendItem" + d.id; })
              .text(function(d, i) { return d.id + ". " + d.label; })
              .style("font-family", "Arial, Helvetica")
              .style("font-size", "11px")
              .on("mouseover", function(d) { showBubble(d); highlightLegendItem(d); })
              .on("mouseout", function(d) { hideBubble(d); unhighlightLegendItem(d); });
      }
    }
  }

  // layer for entries
  var rink = radar.append("g")
    .attr("id", "rink");

  // rollover bubble (on top of everything else)
  var bubble = radar.append("g")
    .attr("id", "bubble")
    .attr("x", 0)
    .attr("y", 0)
    .style("opacity", 0)
    .style("pointer-events", "none")
    .style("user-select", "none");
  bubble.append("rect")
    .attr("rx", 4)
    .attr("ry", 4)
    .style("fill", "#333");
  bubble.append("text")
    .style("font-family", "sans-serif")
    .style("font-size", "10px")
    .style("fill", "#fff");
  bubble.append("path")
    .attr("d", "M 0,0 10,0 5,8 z")
    .style("fill", "#333");

  function showBubble(d) {
    if (d.active || config.print_layout) {
      var tooltip = d3.select("#bubble text")
        .text(d.label);
      var bbox = tooltip.node().getBBox();
      d3.select("#bubble")
        .attr("transform", translate(d.x - bbox.width / 2, d.y - 16))
        .style("opacity", 0.8);
      d3.select("#bubble rect")
        .attr("x", -5)
        .attr("y", -bbox.height)
        .attr("width", bbox.width + 10)
        .attr("height", bbox.height + 4);
      d3.select("#bubble path")
        .attr("transform", translate(bbox.width / 2 - 5, 3));
    }
  }

  function hideBubble(d) {
    var bubble = d3.select("#bubble")
      .attr("transform", translate(0,0))
      .style("opacity", 0);
  }

  function highlightLegendItem(d) {
    var legendItem = document.getElementById("legendItem" + d.id);
    legendItem.setAttribute("filter", "url(#solid)");
    legendItem.setAttribute("fill", "white");
  }

  function unhighlightLegendItem(d) {
    var legendItem = document.getElementById("legendItem" + d.id);
    legendItem.removeAttribute("filter");
    legendItem.removeAttribute("fill");
  }

  // draw blips on radar
  var blips = rink.selectAll(".blip")
    .data(config.entries)
    .enter()
      .append("g")
        .attr("class", "blip")
        .attr("transform", function(d, i) { return legend_transform(d.quadrant, d.ring, i); })
        .on("mouseover", function(d) { showBubble(d); highlightLegendItem(d); })
        .on("mouseout", function(d) { hideBubble(d); unhighlightLegendItem(d); });

  // configure each blip
  blips.each(function(d) {
    var blip = d3.select(this);

    // blip link
    if (d.active && d.hasOwnProperty("link") && d.link) {
      blip = blip.append("a")
        .attr("xlink:href", d.link);

      if (config.links_in_new_tabs) {
        blip.attr("target", "_blank");
      }
    }

    // blip shape
    if (d.moved > 0) {
      blip.append("path")
        .attr("d", "M -11,5 11,5 0,-13 z") // triangle pointing up
        .style("fill", d.color);
    } else if (d.moved < 0) {
      blip.append("path")
        .attr("d", "M -11,-5 11,-5 0,13 z") // triangle pointing down
        .style("fill", d.color);
    } else {
      blip.append("circle")
        .attr("r", 9)
        .attr("fill", d.color);
    }

    // blip text
    if (d.active || config.print_layout) {
      var blip_text = config.print_layout ? d.id : d.label.match(/[a-z]/i);
      blip.append("text")
        .text(blip_text)
        .attr("y", 3)
        .attr("text-anchor", "middle")
        .style("fill", "#fff")
        .style("font-family", "Arial, Helvetica")
        .style("font-size", function(d) { return blip_text.length > 2 ? "8px" : "9px"; })
        .style("pointer-events", "none")
        .style("user-select", "none");
    }
  });

  // make sure that blips stay inside their segment
  function ticked() {
    blips.attr("transform", function(d) {
      return translate(d.segment.clipx(d), d.segment.clipy(d));
    })
  }

  // distribute blips, while avoiding collisions
  d3.forceSimulation()
    .nodes(config.entries)
    .velocityDecay(0.19) // magic number (found by experimentation)
    .force("collision", d3.forceCollide().radius(12).strength(0.85))
    .on("tick", ticked);
}

}



window['Slip'] = (function(){
    'use strict';

    var accessibilityDefaults = {
        // Set values to false if you don't want Slip to manage them
        container: {
            role: "listbox",
            tabIndex: 0,
            focus: false, // focuses after drop
        },
        items: {
            role: "option", // If "option" flattens items, try "group":
            // https://www.marcozehe.de/2013/03/08/sometimes-you-have-to-use-illegal-wai-aria-to-make-stuff-work/
            tabIndex: -1, // 0 will make every item tabbable, which isn't always useful
            focus: false, // focuses when dragging
        },
    };

    var damnYouChrome = /Chrome\/[3-5]/.test(navigator.userAgent); // For bugs that can't be programmatically detected :( Intended to catch all versions of Chrome 30-40
    var needsBodyHandlerHack = damnYouChrome; // Otherwise I _sometimes_ don't get any touchstart events and only clicks instead.

    /* When dragging elements down in Chrome (tested 34-37) dragged element may appear below stationary elements.
       Looks like WebKit bug #61824, but iOS Safari doesn't have that problem. */
    var compositorDoesNotOrderLayers = damnYouChrome;

    // -webkit-mess
    var testElementStyle = document.createElement('div').style;

    var transitionJSPropertyName = "transition" in testElementStyle ? "transition" : "webkitTransition";
    var transformJSPropertyName = "transform" in testElementStyle ? "transform" : "webkitTransform";
    var transformCSSPropertyName = transformJSPropertyName === "webkitTransform" ? "-webkit-transform" : "transform";
    var userSelectJSPropertyName = "userSelect" in testElementStyle ? "userSelect" : "webkitUserSelect";

    testElementStyle[transformJSPropertyName] = 'translateZ(0)';
    var hwLayerMagicStyle = testElementStyle[transformJSPropertyName] ? 'translateZ(0) ' : '';
    var hwTopLayerMagicStyle = testElementStyle[transformJSPropertyName] ? 'translateZ(1px) ' : '';
    testElementStyle = null;

    var globalInstances = 0;
    var attachedBodyHandlerHack = false;
    var nullHandler = function(){};

    function Slip(container, options) {
        if ('string' === typeof container) container = document.querySelector(container);
        if (!container || !container.addEventListener) throw new Error("Please specify DOM node to attach to");

        if (!this || this === window) return new Slip(container, options);

        this.options = options = options || {};
        this.options.keepSwipingPercent = options.keepSwipingPercent || 0;
        this.options.minimumSwipeVelocity = options.minimumSwipeVelocity || 1;
        this.options.minimumSwipeTime = options.minimumSwipeTime || 110;
        this.options.ignoredElements = options.ignoredElements || [];
        this.options.accessibility = options.accessibility || accessibilityDefaults;
        this.options.accessibility.container = options.accessibility.container || accessibilityDefaults.container;

        this.options.accessibility.container.role = options.accessibility.container.role !== undefined ?
            options.accessibility.container.role :
            accessibilityDefaults.container.role;

        this.options.accessibility.container.tabIndex = options.accessibility.container.tabIndex !== undefined ?
            options.accessibility.container.tabIndex :
            accessibilityDefaults.container.tabIndex;

        this.options.accessibility.container.focus = options.accessibility.container.focus !== undefined ?
            options.accessibility.container.focus :
            accessibilityDefaults.container.focus;

        this.options.accessibility.items = options.accessibility.items || accessibilityDefaults.items;

        this.options.accessibility.items.role = options.accessibility.items.role !== undefined ?
            options.accessibility.items.role :
            accessibilityDefaults.items.role;

        this.options.accessibility.items.tabIndex = options.accessibility.items.tabIndex !== undefined ?
            options.accessibility.items.tabIndex :
            accessibilityDefaults.items.tabIndex;

        this.options.accessibility.items.role = options.accessibility.items.focus !== undefined ?
            options.accessibility.items.focus :
            accessibilityDefaults.items.focus;

        if (!Array.isArray(this.options.ignoredElements)) throw new Error("ignoredElements must be an Array");

        // Functions used for as event handlers need usable `this` and must not change to be removable
        this.cancel = this.setState.bind(this, this.states.idle);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchMove = this.onTouchMove.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
        this.onSelection = this.onSelection.bind(this);
        this.onContainerFocus = this.onContainerFocus.bind(this);

        this.setState(this.states.idle);
        this.attach(container);
    }

    function getTransform(node) {
        var transform = node.style[transformJSPropertyName];
        if (transform) {
            return {
                value: transform,
                original: transform,
            };
        }

        if (window.getComputedStyle) {
            var style = window.getComputedStyle(node).getPropertyValue(transformCSSPropertyName);
            if (style && style !== 'none') return {value:style, original:''};
        }
        return {value:'', original:''};
    }

    function findIndex(target, nodes) {
      var originalIndex = 0;
      var listCount = 0;

      for (var i=0; i < nodes.length; i++) {
        if (nodes[i].nodeType === 1) {
          listCount++;
          if (nodes[i] === target.node) {
            originalIndex = listCount-1;
          }
        }
      }

      return originalIndex;
    }

    // All functions in states are going to be executed in context of Slip object
    Slip.prototype = {

        container: null,
        options: {},
        state: null,

        target: null, // the tapped/swiped/reordered node with height and backed up styles

        usingTouch: false, // there's no good way to detect touchscreen preference other than receiving a touch event (really, trust me).
        mouseHandlersAttached: false,

        startPosition: null, // x,y,time where first touch began
        latestPosition: null, // x,y,time where the finger is currently
        previousPosition: null, // x,y,time where the finger was ~100ms ago (for velocity calculation)

        canPreventScrolling: false,

        states: {
            idle: function idleStateInit() {
                this.removeMouseHandlers();
                if (this.target) {
                    this.target.node.style.willChange = '';
                    this.target = null;
                }
                this.usingTouch = false;

                return {
                    allowTextSelection: true,
                };
            },

            undecided: function undecidedStateInit() {
                this.target.height = this.target.node.offsetHeight;
                this.target.node.style.willChange = transformCSSPropertyName;
                this.target.node.style[transitionJSPropertyName] = '';

                if (!this.dispatch(this.target.originalTarget, 'beforewait')) {
                    if (this.dispatch(this.target.originalTarget, 'beforereorder')) {
                        this.setState(this.states.reorder);
                    }
                } else {
                    var holdTimer = setTimeout(function(){
                        var move = this.getAbsoluteMovement();
                        if (this.canPreventScrolling && move.x < 15 && move.y < 25) {
                            if (this.dispatch(this.target.originalTarget, 'beforereorder')) {
                                this.setState(this.states.reorder);
                            }
                        }
                    }.bind(this), 300);
                }

                return {
                    leaveState: function() {
                        clearTimeout(holdTimer);
                    },

                    onMove: function() {
                        var move = this.getAbsoluteMovement();

                        if (move.x > 20 && move.y < Math.max(100, this.target.height)) {
                            if (this.dispatch(this.target.originalTarget, 'beforeswipe', {directionX: move.directionX, directionY: move.directionY})) {
                                this.setState(this.states.swipe);
                                return false;
                            } else {
                                this.setState(this.states.idle);
                            }
                        }
                        if (move.y > 20) {
                            this.setState(this.states.idle);
                        }

                        // Chrome likes sideways scrolling :(
                        if (move.x > move.y*1.2) return false;
                    },

                    onLeave: function() {
                        this.setState(this.states.idle);
                    },

                    onEnd: function() {
                        var allowDefault = this.dispatch(this.target.originalTarget, 'tap');
                        this.setState(this.states.idle);
                        return allowDefault;
                    },
                };
            },

            reorder: function reorderStateInit() {
                if (this.target.node.focus && this.options.accessibility.items.focus) {
                    this.target.node.focus();
                }

                this.target.height = this.target.node.offsetHeight;

                var nodes;
                if (this.options.ignoredElements.length) {
                    var container = this.container;
                    var query = container.tagName.toLowerCase();
                    if (container.getAttribute('id')) {
                        query = '#' + container.getAttribute('id');
                    } else if (container.classList.length) {
                        query += '.' + container.getAttribute('class').replace(' ', '.');
                    }
                    query += ' > ';
                    this.options.ignoredElements.forEach(function (selector) {
                        query += ':not(' + selector + ')';
                    });
                    try {
                        nodes = container.parentNode.querySelectorAll(query);
                    } catch(err) {
                        if (err instanceof DOMException && err.name === 'SyntaxError')
                            throw new Error('ignoredElements you specified contain invalid query');
                        else
                            throw err;
                    }
                } else {
                    nodes = this.container.childNodes;
                }
                var originalIndex = findIndex(this.target, nodes);
                var mouseOutsideTimer;
                var zero = this.target.node.offsetTop + this.target.height/2;
                var otherNodes = [];
                for(var i=0; i < nodes.length; i++) {
                    if (nodes[i].nodeType != 1 || nodes[i] === this.target.node) continue;
                    var t = nodes[i].offsetTop;
                    nodes[i].style[transitionJSPropertyName] = transformCSSPropertyName + ' 0.2s ease-in-out';
                    otherNodes.push({
                        node: nodes[i],
                        baseTransform: getTransform(nodes[i]),
                        pos: t + (t < zero ? nodes[i].offsetHeight : 0) - zero,
                    });
                }

                this.target.node.classList.add('slip-reordering');
                this.target.node.style.zIndex = '99999';
                this.target.node.style[userSelectJSPropertyName] = 'none';
                if (compositorDoesNotOrderLayers) {
                    // Chrome's compositor doesn't sort 2D layers
                    this.container.style.webkitTransformStyle = 'preserve-3d';
                }

                function onMove() {
                    /*jshint validthis:true */

                    this.updateScrolling();

                    if (mouseOutsideTimer) {
                        // don't care where the mouse is as long as it moves
                        clearTimeout(mouseOutsideTimer); mouseOutsideTimer = null;
                    }

                    var move = this.getTotalMovement();
                    this.target.node.style[transformJSPropertyName] = 'translate(0,' + move.y + 'px) ' + hwTopLayerMagicStyle + this.target.baseTransform.value;

                    var height = this.target.height;
                    otherNodes.forEach(function(o){
                        var off = 0;
                        if (o.pos < 0 && move.y < 0 && o.pos > move.y) {
                            off = height;
                        }
                        else if (o.pos > 0 && move.y > 0 && o.pos < move.y) {
                            off = -height;
                        }
                        // FIXME: should change accelerated/non-accelerated state lazily
                        o.node.style[transformJSPropertyName] = off ? 'translate(0,'+off+'px) ' + hwLayerMagicStyle + o.baseTransform.value : o.baseTransform.original;
                    });
                    return false;
                }

                onMove.call(this);

                return {
                    leaveState: function() {
                        if (mouseOutsideTimer) clearTimeout(mouseOutsideTimer);

                        if (compositorDoesNotOrderLayers) {
                            this.container.style.webkitTransformStyle = '';
                        }

                        if (this.container.focus && this.options.accessibility.container.focus) {
                            this.container.focus();
                        }

                        this.target.node.classList.remove('slip-reordering');
                        this.target.node.style[userSelectJSPropertyName] = '';

                        this.animateToZero(function(target){
                            target.node.style.zIndex = '';
                        });
                        otherNodes.forEach(function(o){
                            o.node.style[transformJSPropertyName] = o.baseTransform.original;
                            o.node.style[transitionJSPropertyName] = ''; // FIXME: animate to new position
                        });
                    },

                    onMove: onMove,

                    onLeave: function() {
                        // don't let element get stuck if mouse left the window
                        // but don't cancel immediately as it'd be annoying near window edges
                        if (mouseOutsideTimer) clearTimeout(mouseOutsideTimer);
                        mouseOutsideTimer = setTimeout(function(){
                            mouseOutsideTimer = null;
                            this.cancel();
                        }.bind(this), 700);
                    },

                    onEnd: function() {
                        var move = this.getTotalMovement();
                        var i, spliceIndex;
                        if (move.y < 0) {
                            for (i=0; i < otherNodes.length; i++) {
                                if (otherNodes[i].pos > move.y) {
                                    break;
                                }
                            }
                            spliceIndex = i;
                        } else {
                            for (i=otherNodes.length-1; i >= 0; i--) {
                                if (otherNodes[i].pos < move.y) {
                                    break;
                                }
                            }
                            spliceIndex = i+1;
                        }

                        this.dispatch(this.target.node, 'reorder', {
                            spliceIndex: spliceIndex,
                            originalIndex: originalIndex,
                            insertBefore: otherNodes[spliceIndex] ? otherNodes[spliceIndex].node : null,
                        });

                        this.setState(this.states.idle);
                        return false;
                    },
                };
            },
        },

        attach: function(container) {
            globalInstances++;
            if (this.container) this.detach();

            // In some cases taps on list elements send *only* click events and no touch events. Spotted only in Chrome 32+
            // Having event listener on body seems to solve the issue (although AFAIK may disable smooth scrolling as a side-effect)
            if (!attachedBodyHandlerHack && needsBodyHandlerHack) {
                attachedBodyHandlerHack = true;
                document.body.addEventListener('touchstart', nullHandler, false);
            }

            this.container = container;

            // Accessibility
            if (false !== this.options.accessibility.container.tabIndex) {
                this.container.tabIndex = this.options.accessibility.container.tabIndex;
            }
            if (this.options.accessibility.container.role) {
                this.container.setAttribute('role', this.options.accessibility.container.role);
            }
            this.setChildNodesRoles();
            this.container.addEventListener('focus', this.onContainerFocus, false);

            this.otherNodes = [];

            // selection on iOS interferes with reordering
            document.addEventListener("selectionchange", this.onSelection, false);

            // cancel is called e.g. when iOS detects multitasking gesture
            this.container.addEventListener('touchcancel', this.cancel, false);
            this.container.addEventListener('touchstart', this.onTouchStart, false);
            this.container.addEventListener('touchmove', this.onTouchMove, false);
            this.container.addEventListener('touchend', this.onTouchEnd, false);
            this.container.addEventListener('mousedown', this.onMouseDown, false);
            // mousemove and mouseup are attached dynamically
        },

        setState: function(newStateCtor){
            if (this.state) {
                if (this.state.ctor === newStateCtor) return;
                if (this.state.leaveState) this.state.leaveState.call(this);
            }

            // Must be re-entrant in case ctor changes state
            var prevState = this.state;
            var nextState = newStateCtor.call(this);
            if (this.state === prevState) {
                nextState.ctor = newStateCtor;
                this.state = nextState;
            }
        },

        findTargetNode: function(targetNode) {
            while(targetNode && targetNode.parentNode !== this.container) {
                targetNode = targetNode.parentNode;
            }
            return targetNode;
        },

        onContainerFocus: function(e) {
            e.stopPropagation();
            this.setChildNodesRoles();
        },

        setChildNodesRoles: function() {
            var nodes = this.container.childNodes;
            for(var i=0; i < nodes.length; i++) {
                if (nodes[i].nodeType != 1) continue;
                if (this.options.accessibility.items.role) {
                    nodes[i].setAttribute('role', this.options.accessibility.items.role);
                }
                if (false !== this.options.accessibility.items.tabIndex) {
                    nodes[i].tabIndex = this.options.accessibility.items.tabIndex;
                }
            }
        },

        unSetChildNodesRoles: function() {
            var nodes = this.container.childNodes;
            for(var i=0; i < nodes.length; i++) {
                if (nodes[i].nodeType != 1) continue;
                if (this.options.accessibility.items.role) {
                    nodes[i].removeAttribute('role');
                }
                if (false !== this.options.accessibility.items.tabIndex) {
                    nodes[i].removeAttribute('tabIndex');
                }
            }
        },
        onSelection: function(e) {
            e.stopPropagation();
            var isRelated = e.target === document || this.findTargetNode(e);
            var iOS = /(iPhone|iPad|iPod)/i.test(navigator.userAgent) && !/(Android|Windows)/i.test(navigator.userAgent);
            if (!isRelated) return;

            if (iOS) {
                // iOS doesn't allow selection to be prevented
                this.setState(this.states.idle);
            } else {
                if (!this.state.allowTextSelection) {
                    e.preventDefault();
                }
            }
        },

        addMouseHandlers: function() {
            // unlike touch events, mousemove/up is not conveniently fired on the same element,
            // but I don't need to listen to unrelated events all the time
            if (!this.mouseHandlersAttached) {
                this.mouseHandlersAttached = true;
                document.documentElement.addEventListener('mouseleave', this.onMouseLeave, false);
                window.addEventListener('mousemove', this.onMouseMove, true);
                window.addEventListener('mouseup', this.onMouseUp, true);
                window.addEventListener('blur', this.cancel, false);
            }
        },

        removeMouseHandlers: function() {
            if (this.mouseHandlersAttached) {
                this.mouseHandlersAttached = false;
                document.documentElement.removeEventListener('mouseleave', this.onMouseLeave, false);
                window.removeEventListener('mousemove', this.onMouseMove, true);
                window.removeEventListener('mouseup', this.onMouseUp, true);
                window.removeEventListener('blur', this.cancel, false);
            }
        },

        onMouseLeave: function(e) {
            e.stopPropagation();
            if (this.usingTouch) return;

            if (e.target === document.documentElement || e.relatedTarget === document.documentElement) {
                if (this.state.onLeave) {
                    this.state.onLeave.call(this);
                }
            }
        },

        onMouseDown: function(e) {
            e.stopPropagation();
            if (this.usingTouch || e.button != 0 || !this.setTarget(e)) return;

            this.addMouseHandlers(); // mouseup, etc.

            this.canPreventScrolling = true; // or rather it doesn't apply to mouse

            this.startAtPosition({
                x: e.clientX,
                y: e.clientY,
                time: e.timeStamp,
            });
        },

        onTouchStart: function(e) {
            e.stopPropagation();
            this.usingTouch = true;
            this.canPreventScrolling = true;

            // This implementation cares only about single touch
            if (e.touches.length > 1) {
                this.setState(this.states.idle);
                return;
            }

            if (!this.setTarget(e)) return;

            this.startAtPosition({
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
                time: e.timeStamp,
            });
        },

        setTarget: function(e) {
            var targetNode = this.findTargetNode(e.target);
            if (!targetNode) {
                this.setState(this.states.idle);
                return false;
            }

            // scrollContainer may be explicitly set via options, otherwise search upwards for a parent with an overflow-y property
            // fallback to document.scrollingElement (or documentElement on IE), and do not use document.body
            var scrollContainer = this.options.scrollContainer;
            if (!scrollContainer) {
                var top = document.scrollingElement || document.documentElement;
                scrollContainer = targetNode.parentNode;
                while (scrollContainer) {
                    if (scrollContainer == top) break;
                    if (scrollContainer != document.body && scrollContainer.scrollHeight > scrollContainer.clientHeight && window.getComputedStyle(scrollContainer)['overflow-y'] != 'visible') break;
                    scrollContainer = scrollContainer.parentNode;
                }
                scrollContainer = scrollContainer || top;
            }

            this.target = {
                originalTarget: e.target,
                node: targetNode,
                scrollContainer: scrollContainer,
                origScrollTop: scrollContainer.scrollTop,
                origScrollHeight: scrollContainer.scrollHeight,
                baseTransform: getTransform(targetNode),
            };
            return true;
        },

        startAtPosition: function(pos) {
            this.startPosition = this.previousPosition = this.latestPosition = pos;
            this.setState(this.states.undecided);
        },

        updatePosition: function(e, pos) {
            if (this.target == null) {
                return;
            }
            this.latestPosition = pos;

            if (this.state.onMove) {
                if (this.state.onMove.call(this) === false) {
                    e.preventDefault();
                }
            }

            // sample latestPosition 100ms for velocity
            if (this.latestPosition.time - this.previousPosition.time > 100) {
                this.previousPosition = this.latestPosition;
            }
        },

        onMouseMove: function(e) {
            e.stopPropagation();
            this.updatePosition(e, {
                x: e.clientX,
                y: e.clientY,
                time: e.timeStamp,
            });
        },

        onTouchMove: function(e) {
            e.stopPropagation();
            this.updatePosition(e, {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
                time: e.timeStamp,
            });

            // In Apple's touch model only the first move event after touchstart can prevent scrolling (and event.cancelable is broken)
            this.canPreventScrolling = false;
        },

        onMouseUp: function(e) {
            e.stopPropagation();
            if (this.usingTouch || e.button !== 0) return;

            if (this.state.onEnd && false === this.state.onEnd.call(this)) {
                e.preventDefault();
            }
        },

        onTouchEnd: function(e) {
            e.stopPropagation();
            if (e.touches.length > 1) {
                this.cancel();
            } else if (this.state.onEnd && false === this.state.onEnd.call(this)) {
                e.preventDefault();
            }
        },

        getTotalMovement: function() {
            var scrollOffset = this.target.scrollContainer.scrollTop - this.target.origScrollTop;
            return {
                x: this.latestPosition.x - this.startPosition.x,
                y: this.latestPosition.y - this.startPosition.y + scrollOffset,
                time: this.latestPosition.time - this.startPosition.time,
            };
        },

        getAbsoluteMovement: function() {
            var move = this.getTotalMovement();
            return {
                x: Math.abs(move.x),
                y: Math.abs(move.y),
                time: move.time,
                directionX: move.x < 0 ? 'left' : 'right',
                directionY: move.y < 0 ? 'up' : 'down',
            };
        },

        updateScrolling: function() {
            var triggerOffset = 40,
                offset = 0;

            var scrollable = this.target.scrollContainer,
                containerRect = scrollable.getBoundingClientRect(),
                targetRect = this.target.node.getBoundingClientRect(),
                bottomOffset = Math.min(containerRect.bottom, window.innerHeight) - targetRect.bottom,
                topOffset = targetRect.top - Math.max(containerRect.top, 0),
                maxScrollTop = this.target.origScrollHeight - Math.min(scrollable.clientHeight, window.innerHeight);

            if (bottomOffset < triggerOffset) {
              offset = Math.min(triggerOffset, triggerOffset - bottomOffset);
            }
            else if (topOffset < triggerOffset) {
              offset = Math.max(-triggerOffset, topOffset - triggerOffset);
            }

            scrollable.scrollTop = Math.max(0, Math.min(maxScrollTop, scrollable.scrollTop + offset));
        },

        dispatch: function(targetNode, eventName, detail) {
            var event = document.createEvent('CustomEvent');
            if (event && event.initCustomEvent) {
                event.initCustomEvent('slip:' + eventName, true, true, detail);
            } else {
                event = document.createEvent('Event');
                event.initEvent('slip:' + eventName, true, true);
                event.detail = detail;
            }
            return targetNode.dispatchEvent(event);
        },

        animateToZero: function(callback, target) {
            // save, because this.target/container could change during animation
            target = target || this.target;

            target.node.style[transitionJSPropertyName] = transformCSSPropertyName + ' 0.1s ease-out';
            target.node.style[transformJSPropertyName] = 'translate(0,0) ' + hwLayerMagicStyle + target.baseTransform.value;
            setTimeout(function(){
                target.node.style[transitionJSPropertyName] = '';
                target.node.style[transformJSPropertyName] = target.baseTransform.original;
                if (callback) callback.call(this, target);
            }.bind(this), 101);
        },


    };

    // AMD
    if ('function' === typeof define && define.amd) {
        define(function(){
            return Slip;
        });
    }
    // CJS
    if ('object' === typeof module && module.exports) {
        module.exports = Slip;
    }
    return Slip;

})();



    function setupSlip(list) {
        list.addEventListener('slip:beforeswipe', function(e){
            if (e.target.nodeName == 'INPUT' || e.target.classList.contains('demo-no-swipe')) {
                e.preventDefault();
            }
        }, false);
        list.addEventListener('slip:beforewait', function(e){
            if (e.target.classList.contains('instant')) e.preventDefault();
        }, false);
        list.addEventListener('slip:reorder', function(e){
            e.target.parentNode.insertBefore(e.target, e.detail.insertBefore);
            return false;
        }, false);
        return new Slip(list);
    }
    setupSlip(document.getElementById('demo1'));
    setupSlip(document.getElementById('demo2'));
    setupSlip(document.getElementById('demo3'));
    setupSlip(document.getElementById('demo4'));
    //setupSlip(document.getElementById('demo-nested'));



  </script>
    

</body>
</html>